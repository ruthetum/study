# Chapter04. 아키텍처
- [MySQL 엔진 아키텍처](#mysql-엔진-아키텍처)
    + [MySQL 전체 구조](#mysql-전체-구조)
    + [MySQL 스레딩 구조](#mysql-스레딩-구조)
    + [메모리 할당 및 사용 구조](#메모리-할당-및-사용-구조)
    + [플러그인 스토리지 엔진 모델](#플러그인-스토리지-엔진-모델)
    + [컴포넌트](#컴포넌트)
    + [쿼리 실행 구조](#쿼리-실행-구조)
    + [복제](#복제)
    + [쿼리 캐시](#쿼리-캐시)
    + [스레드 풀](#스레드-풀)
- [InnoDB 스토리지 엔진 아키텍처](#innodb-스토리지-엔진-아키텍처)

---

# MySQL 엔진 아키텍처
## MySQL 전체 구조
- MySQL은 다른 DBMS에 비해 독특한 구조
  - 이로 인해 장/단점이 존재

- MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분할 수 있음
  ```go
  MySQL Server = MySQL Engine(쿼리 분석, 최적화) + Storage Engine(실제 데이터 접근)
  ```
  - MySQL Engine: SQL interface, SQL parser, SQL optimizer, Cache & Buffer, Connection Handler
  - Storage Engine: InnoDB, MyISAM, Memory...

### MySQL 엔진
- 클라이언트로부터의 접속 및 쿼리 요청을 처리(커넥션 핸들러)
- SQL 파싱 및 전처리
- 쿼리의 최적화된 실행

### Storage 엔진
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 담당
- MySQL 서버에서 MySQL 엔진은 하나지만 Storage 엔진은 여러 개를 사용할 수 있음
- 아래 쿼리처럼 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 읽기/변경 작업은 해당 스토리지 엔진이 처리
  ```
  mysql> CREATE TABLE users (col1 INT, col2 INT) ENGINE=INNODB
  ```
- MySQL의 스토리지 엔진은 플러그인 방식이며, 기본적으로 8가지의 스토리지 엔진이 탑재
  ```
  mysql> SHOW ENGINES;
  ```

> Ref. Storage 엔진 설명
> - storage 엔진 관련 공식 문서: https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html
> - 엔진 설명 포스트 1: https://nomadlee.com/mysql-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%A2%85%EB%A5%98-%EB%B0%8F-%ED%8A%B9%EC%A7%95/
> - 엔진 설명 포스트 2: http://asuraiv.blogspot.com/2017/07/mysql-storage-engine.html

## MySQL 스레딩 구조
- MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동
- 포그라운드 스레드와 백그라운드 스레드로 구분

    ```
    mysql> SELECT thread_id, name, type, proccesslist_user, processlist_host
           FROM performance_schema.threads ORDER BY type, thread_id; 
    ```

### 포그라운드 스레드(클라이언트 스레드)
- 포그라운드 스레드는 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재, 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시로 되돌아감
  - 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료 -> 일정 개수의 스레드 캐시 수(`thread_chach_size`)를 유지
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어옴

#### InnoDB
- 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리

#### MyISAM
- 포그라운드 스레드가 디스크 쓰기 작업까지 처리
- MyISAM도 지연 쓰기를 활용할 수 있지만 일반적이지 않음

### 백그라운드 스레드
- MyISAM의 경우 별로 해당 사항 없음(디스크 쓰기 작업까지 처리하기 때문)
- InnoDB는 아래 작업을 백그라운드로 처리
  - 인서트 버퍼(Insert buffer)를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드 (**로그 스레드**)
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 (**쓰기 스레드**)
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 5.5 버전부터 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됨
  - `innodb_write_io_threads`, `innodb_read_io_threads`로 스레드 개수 설정
- InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 실행되기 때문에 읽기 스레드는 많이 설정할 필요 없음
- 쓰기 스레드는 대부분의 많은 작업을 백그라운드로 처리하기 때문에 일반적으로 2~4 정도 설정

## 메모리 할당 및 사용 구조
|                             글로벌 메모리 영역                             |               로컬 메모리 영역               |
|:------------------------------------------------------------------:|:-------------------------------------:|
| InnoDB 버퍼 풀<br/>MyISAM 키 캐시<br/>바이너리 로그 버퍼<br/>리두 로그 버퍼<br/>테이블 캐시 | 조인 버퍼<br/>정렬 버퍼<br/>네트워크 버퍼<br/>리드 버퍼 |

- MySQL 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분

### 글로벌 메모리 영역
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 OS로부터 할당
  - OS에 따라 한 번에 100%를 할당할 수도 있고, 조금씩 할당해주는 경우도 존재
- 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당

### 로컬 메모리 영역(세션 메모리 영역)
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유하지 않음

## 플러그인 스토리지 엔진 모델
- 플러그인 모델이기 때문에 원하는 플러그인을 갈아끼워서 적용할 수 있음

## 컴포넌트
- 플러그인 아키텍처에는 아래와 같은 단점이 존재
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신할 수 없음
  - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전한지 않음(캡슐화 X)
  - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화에 어려움 존재
- 이와 같은 단점들을 보완하기 위해 컴포넌트 아키텍처를 지원

## 쿼리 실행 구조
```
0. 사용자의 SQL 요청
1. 쿼리 파서            // 토큰 분리, 트리 생성, 문법 오류 파악
2. 전처리기             // 토큰 매핑, 접근 권한 확인
3. 옵티마이저            // 쿼리 변환, 비용 최적화, 실행 계획 수립
4. 쿼리 실행기 
5. 스토리지 엔진 접근
6. SQL 결과
```

### 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 기호)으로 분리해서 트리 구조를 생성
- 이 과정에서 기본 문법 오류를 파악

### 전처리기
- 트리 구조의 쿼리 문장에 구조적인 문제점이 있는지 파악
- 테이블이나 컬럼 이름, 내장 함수같은 개체를 매핑해서 해당 객체의 존재 여부와 객체의 접근 권한을 확인

### 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할
- 쿼리 변환 비용 최적화, 실행 계획 수립

### 쿼리 실행기(실행 엔진)
- 옵티마이저에 의해 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸드렁의 요청의 입력으로 연결

### 스토리지 엔진(핸들러)
- 데이터를 디스크에 저장, 읽어오는 역할 담당

## 복제
- 16장에서 자세히

## 쿼리 캐시
- SQL 실행 결과를 메모리에 캐시하고 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 결과를 반환
- 테이블의 데이터가 변경되면 캐시에 저장된 결과 중 관련된 것들은 모두 삭제
- 성능 저하 및 버그의 원인이기 때문에 사용 권장 X
- 8.0으로 오면서 관련 기능은 Deprecated

## 스레드 풀
- MySQL 서버 엔터프라이즈 에디션은 스레드 풀 기능을 제공하지만, 커뮤니티 에디션은 스레드 풀 기능을 지원하지 않음
- 결국 목적은 제한된 개수의 스레드 처리에만 집중하고, 반복해서 생성.삭제하는 코스트를 줄이는 역할

# InnoDB 스토리지 엔진 아키텍처