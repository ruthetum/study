# Chapter09. 옵티마이저와 힌트

# 옵티마이저 (Optimizer)
실제로 **SQL문을 실행하기 전**에 비용 기반으로 다양한 **최적의 실행계획을 세우고 결정**하는 작업 담당

## 쿼리 실행 절차

![image](https://user-images.githubusercontent.com/59307414/209309738-a7ab737a-3551-4ffd-9838-64c989f36d6c.png)

- 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계정보를 참조하며 최적의 실행 계획을 수립하는 역할
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

## 옵티마이저의 종류
> - 규칙 기반 최적화(Rule-based optimizer, RBO): 테이블의 레코드, 분포도를 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립 -> 안 씀
> - 비용 기반 최적화(Cost-based optimizer, CBO): 각 단위 작업의 비용(부하) 정보를 고려하여 실행 계획 비용 산출, 산출된 비용이 최소로 소요되는 처리 방식을 선택

- MySQL의 옵티마이저는 아래와 같은 통계 정보를 통해 비용 기반 최적화를 수행
  - 대략의 레코드 건수
  - 인덱스의 유니크한 값의 개수

# 데이터 처리 방법
## 풀 테이블 스캔과 풀 인덱스 스캔
> - 풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식
> - 풀 인덱스 스캔: 인덱스 리프 블록 처음부터 끝까지 수평적으로 읽는 방식

### 퓰 테이블 스캔이 선택되는 조건
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - 일반적으로 테이블이 페이지 1개로 구성된 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
  - 인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준

### 풀 테이블 스캔 실행
풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드(클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업 백그라운드 스레드로 넘김

- 일반적으로 테이블의 전체 크기가 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 매우 큰 디스크 읽기 작업이 필요
  - 그래서 대부분 DBMS는 풀 테이블 스캔 실행 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능 내장
- 하지만 MySQL에는 풀 테이블 스캔 실행 시 한 번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수가 없음
  - 그래서 간혹 MySQL에서 풀 테이블 스캔 실행 시 디스크로부터 페이지를 하나씩 읽어 오는 것으로 오인하는 경우 존재
- InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(read ahead) 작업이 자동으로 시작
  - 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것
- 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개의 페이지를 읽으면서 계속 수를 증가시키
  - 한 번에 최대 64개의 페이지까지 읽어서 버퍼 풀에 저장
  - 포그라운드 스레드는 버퍼 풀에 저장된 데이터를 읽음
- `innodb_read_ahead_threshold` 시스템 변수를 이용하여 리드 어헤드의 임계값 설정 가능
- 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용

    ```mysql
    SELECT COUNT(*) FROM tbl
    ```

  - 위 쿼리는 아무런 조건이 없기 때문에 풀 테이블 스캔을 할 것처럼 보이지만 실제 실행계획은 풀 인덱스 스캔을 선택
    - 테이블을 전체 조회하는 것보다 인덱스만을 조회하는 것이 용량이 적기 때문
  - 하자만 `SELECT * FROM tbl` 이런 형태로 레코드에 있는 컬럼의 정보를 조회하는 경우에는 풀 인덱스 스캔을 사용하지 못 하고 풀 테이블 스캔 적용

## 병렬 처리
> 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것

- `innodb_parallel_read_threads` 시스템 변수를 이용하여 하나의 쿼리를 여러 개의 스레드를 이용해서 처리할 수 있음
- 병렬 처리용 스레드 개수가 증가시키는 경우 쿼리 처리 시간이 감소 (일부 성능 향상)
  - 하지만 스레드 개수를 아무리 늘리더라도 서버에 정착된 CPU의 코어 개수를 넘어서는 경우 오히려 성능 저하 발생할 수 있음

## ORDER BY 처리 (Using filesort)
- 레코드 1-2건을 가져오는 쿼리가 아닌 이상 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 Filesort를 이용하는 방법으로 나눌 수 있음

|    정렬 방법    | 장점                                                                                            | 단점                                                                                                                                   |
|:-----------:|-----------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
|   인덱스 이용    | INSERT, UPDATE, DELETE가 실행될 때 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되기 때문에 빠름                             | INSERT, UPDATE, DELETE가 실행될 때 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림.<br/>인덱스 때문에 디스크 공간이 더 많이 필요하고, 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 더 많이 필요 |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스와 관련된 추가 작업이 필요하지 않음<br/>정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리하므로 속도가 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느려짐                                                                                  |
- filesort를 이용하는 경우 실행 계획의 `extra` 컬럼에서 `Using filesort` 메세지를 통해 사용 여부 확인
  - `Using filesort`: `ORDER BY` 작업 시 인덱스를 사용하지 못했음을 의미

### 소트 버퍼
- 정렬을 수행하기 위해 별도의 메모리 공간
  - 세션 메모리 영역에 할당 -> 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아님
- 정렬이 필요한 경우에만 할당되며 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가
- `sort_buffer_size` 시스템 변수로 최대 사용 가능한 버퍼의 크기를 설정할 수 있음
- 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되는 순간 시스템으로 반납

> 만약 정렬해야 할 레코드의 건수가 소프 버퍼로 할당된 공간보다 크다면?
- 정렬해야 할 레코드를 여러 조각으로 나눠서 처리
  - 이 과정에서 임시 저장을 위해 디스크를 사용
- 메모리의 소트 버퍼에서 정렬 수행 -> 결과를 임시 디스크에 저장 -> 다음 레코드를 가져와서 다시 정렬 수행 -> 저장하는 과정을 반복
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행
  - 이 병합 작업을 멀티 머지(multi merge)라고 표현
  - 수행된 멀티 머지 횟수는 `sort_merge_passes` 상태 변수에 누적해서 집계
- 결국 이 작업들이 디스크의 쓰기/읽기를 유발하고, 레코드 건수가 많을수록 반복 작업의 횟수가 증가
  - 소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 성능이 개선될 수 있다고 생각할 수 있지만 실제 벤치마크 결과를 확인해보면 별 차이 없음
    - 빠른 성능을 얻을 수는 없지만 디스크의 읽기/쓰기 사용량은 줄일 수 있음
  - 오히려 소트 버퍼 사이즈(`sort_buffer_size`)를 너무 크게 설정하면 큰 메모리 공간 할당으로 인해 오히려 성능 저하
- 일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB에서 1MB 미만이 적절함

### 정렬 알고리즘
|         정렬 모드          | 설명                                                                       | 효율적인 상황                  |
|:----------------------:|--------------------------------------------------------------------------|--------------------------|
| 싱글 패스<br>(Single-pass) | SELECT 대상이 되는 컬럼을 전부 담아서 정렬을 수행하는 방식<br/>(정렬이 필요하지 않은 컬럼까지 모두 읽음)        | 정렬 대상 레코드의 크기나 건수가 작은 경우 |
|   투 패스<br>(Two-pass)   | 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 원하는 컬럼을 조회 | 정렬 대상 레코드의 크거나 건수가 많은 경우 |

#### 싱글 패스 vs 투 패스

- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 비효율적, 따라서 일반적으로 싱글 패스 방식을 이용
- 하지만 싱글 패스 방식은 투 패스 방식에 비해 더 큰 소트 버퍼가 필요하므 아래의 상황에서는 투 패스 방식을 이용
  - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
  - BLOB이나 TEXT 컬럼이 SELECT 대상에 포함될 때

### 정렬 처리 방법
- `ORDER BY` 작업 시 아래 3가지 처리 방법 중 하나로 정렬이 처리됨
  - 표에서 아래 쪽으로 내려갈수록 처리 속도가 떨어짐

|          정렬 처리 방법           | 실행 계획의 `extra` 컬럼 내용                 |
|:---------------------------:|--------------------------------------|
|         인덱스를 이용한 정렬         | 별도 표기 없음                             |
|      조인에서 드라이빙 테이블만 정렬      | `Using filesort` 표기                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | `Using temporary; Using filesort` 표기 |

- 인덱스를 사용할 수 없는 경우 레코드를 검색해 정렬 버퍼에 저장하면서 정렬 처리(filesort)
- 이 때 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 아래 2가지 방법 중 하나를 선택
  - 조인의 드라이브 테이블만 정렬한 다음 조인을 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행
- 일반적으로 조인이 수행되면 레코드 크기가 커지기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적

> Nested Loop, Driving/Driven table
> - NESTED LOOP JOIN은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 조인 방식
> - https://coding-factory.tistory.com/756

#### 인덱스를 이용한 정렬
- 반드시 `ORDER BY`에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, `ORDER BY`의 순서대로 생성된 인덱스가 있어야 함
- 인덱스를 이용한 정렬이 처리되는 경우 실제 인덱스 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 됨
  - MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않음

#### 조인에서 드라이빙 테이블만 정렬
- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행
- 조인에서 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 `ORDER BY` 절을 작성
  - 드리븐 테이블의 컬럼이 `ORDER BY` 절에 작성되어 있으면 조인 전에 정렬이 불가능

#### 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
- 조인 후 결과를 임시 테이블에 저장
  - 인덱스를 이용하거나 드라이빙 테이블을 이용하여 정렬하는 경우 임시 테이블이 필요하지 않음
- 3가지 정렬 방법 중 정렬해야할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법


### 스트리밍 방식 vs 버퍼링 방식
- 보통 웹 서비스용 쿼리에서는 `ORDER BY`와 함께 `LIMIT`이 거의 필수로 사용
- `ORDER BY`, `GROUP BY` 같은 작업은 `WHERE`조건을 만족하는 레코드를 `LIMIT` 건수만큼 가져와서 처리할 수 없음
  - 우선 조건을 만족하는 모든 레코드를 가져와서 정렬 또는 그룹핑해야 함
- `WHERE` 조건이 아무리 인덱스를 잘 활용해도 `ORDER BY`, `GROUP BY`를 잘못 사용하는 경우 쿼리 속도가 느려질 수 있음

#### 스트리밍 방식
- 서버 쪽에서 처리할 데이터 수에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트로 전송해주는 방식
- 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있음
- `LIMIT`처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있음
- 정렬 처리 방법 중 **인덱스를 사용한 방법**에 해당

#### 버퍼링 방식
- `ORDER BY`나 `GROUP BY`같은 처리는 쿼리의 결과를 스트리밍 방식으로 처리할 수 없음
- 모든 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 함
- `LIMIT`처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음
- 정렬 처리 방법 중 **조인에서 드라이빙 테이블만 정렬**, **조인에서 조인 결과를 임시 테이블로 저장 후 정렬**에 해당

## GROUP BY 처리
- `ORDER BY`와 마찬가지로 `GROUP BY` 또한 스트리밍 처리를 할 수 없는 방식
- `GROUP BY`절이 있는 쿼리에서는 필터링 역할을 하는 `HAVING`절을 사용할 수 있음
  - `GROUP BY`에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 `HAVING`절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없음
- `GROUP BY` 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 분류 가능
  - 인덱스를 사용하는 경우: 인덱스를 차례 대로 읽는 스캔(타이트 인덱스 스캔), 루스 인덱스 스캔
  - 인덱스를 사용하지 못 하는 경우: 임시 테이블 사용

|  정렬 처리 방법  | 실행 계획의 `extra` 컬럼 내용                     |
|:----------:|------------------------------------------|
| 타이트 인덱스 스캔 | 별도 표기 없음                                 |
| 루스 인덱스 스캔  | `Using index for group by` 표기 |
| 임시 테이블 사용  | `Using temporary` 표기       |

### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- `ORDER BY`와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑 할 때 `GROUP BY` 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리
  - `GROUP BY`가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹 값을 처리해야 해서 임시 테이블이 필요할 때도 있음

### 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 실행 계획의 `extra` 컬럼에 `Using index for group by` 표기
- 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용할 수 있음
  - 추가로 프리픽스 인덱스(컬럼값의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없음
- 일반적으로 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록(커디널리티가 높을수록) 성능이 향상되지만, 루스 인덱스 스캔은 인덱스의 유니크한 값의 수가 적을수록(커디널리티가 낮을수록) 성능이 향상

#### 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
```mysql
# MIN(), MAX() 이외의 집합 함수가 사용되는 경우
SELECT col1, SUM(col2) FROM tbl GROUP BY col1;

# GROUP BY에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않은 경우
SELECT col1, col2 FROM tbl GROUP BY col2, col3;

# SELECT 절의 컬럼이 GROUP BY와 일치하지 않은 경우
SELECT col1, col3 FROM tbl GROUP BY col1, col2;
```

### 임시 테이블을 사용하는 GROUP BY
- `GROUP BY`의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 임시 테이블을 활용
- 실행 계획의 `extra` 컬럼에 `Using temporary` 표기

> `ORDER BY NULL`
- 5.7 버전까지는 `GROUP BY`가 사용되면 자동으로 그룹핑 컬럼을 기준으로 정렬 수행
  - 정렬이 필요하지 않는 경우 `ORDER BY NULL`을 추가로 작성할 것을 권장
  - `ORDER BY NULL`이 사용되면 MySQL 서버는 불필요한 추가 정렬 작업을 수행하지 않으므로 일정 부분 성능 향상
- 8.0 버전부터는 `GROUP BY`를 사용하더라도 묵시적인 정렬이 수행되지 않기 때문에 정렬된 결과가 필요하지 않은 경우 굳이 `ORDER BY NULL`을 추가할 필요 없음

## DISTINCT 처리
- `DISTINCT`는 `MIN()`, `MAX()`, `COUNT()` 같은 집합함수와 함께 사용되는 경우와 집합 함수가 없는 2가지 경우로 구분
  - 위의 경우에 따라 `DISTINCT` 키워드의 영향 범위가 달라짐
  - 집합 함수와 같이 `DISTINCT`가 사용되는 경우 실행 계획에서 `DISTINCT` 처리가 인덱스를 사용하지 못할 때는 임시 테이블이 필요
    - 하지만 실행 계획의 `extra` 컬럼에는 `Using temporary`가 표기되지 않음

### SELECT DISTINCT ...
- 단순 `SELECT` 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 `SELECT DISTINCT` 형태의 쿼리 문장을 사용
  - 이 경우에는 `GROUP BY`와 동일한 방식으로 처리
    
    ```mysql
    # 두 쿼리는 내부적으로 같은 작업을 수행
    SELECT DISTINCT emp_no FROM tbl;
    SELECT emp_no FROM tbl GROUP BY emp_no;
    ```

- `DISTINCT`는 `SELECT`하는 레코드 유니크하게 조회하는 것이지, 특정 컬럼만 유니크하게 조회하는 것이 아님

  ```mysql
  # 특정 컬럼이 아닌 컬럼의 조합을 기준으로 유니크한 레코드를 조회
  # 아래 두 쿼리는 같은 결과 반환
  SELECT DISTINCT col1, col2 FROM tbl;
  SELECT DISTINCT(col1), col2 FROM tbl; # 괄호는 의미 없음, 파서에서 괄호 제거(의미없는 구문)
  ```

### 집합 함수와 함께 사용되는 DISTINCT
- `MIN()`, `MAX()`, `COUNT()` 같은 집합 함수에서 `DISTINCT` 키워드를 사용하면 ₩`SELECT DISTINCT`와 다른 형태로 해석
  - 집합 함수가 없을 때는 `DISTINCT`는 조회하는 모든 컬럼의 조합이 유니크한 것만 조회
  - 집합 함수가 있을 때는 `DISTINCT`는 그 집함 함수의 인자로 전달된 컬럼값이 유니크한 것을 조회
- 쿼리의 실행 계획에서 `DISTINCT`가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요
  - 하지만 실행 계획의 `extra` 칼럼에는 `Using temporary` 메세지가 표기되지 않음


## 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드들을 정렬하거나 그룹핑 할 때는 내부적인 임시 테이블을 사용
  - `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블과 다름
- 내부적인 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨짐
- 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제

### 메모리 임시 테이블과 디스크 임시 테이블
- 8.0 이전 버전까지는 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하고, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 사용
- 8.0 버전부터는 메모리는 기본값으로 TempTable 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선
  - MEMORY 테이블은 `VARBINARY`, `VARCHAR` 등 가변 길이 타입을 지원하지 못해 메모리 낭비가 심해지는 문제점이 존재 → TempTable 스토리지 엔진은 가변 길이 타입을 지원
  - MyISAM 테이블은 트랜잭션을 지원하지 못함 → InnoDB 스토리지 엔진은 트랜잭션을 지원
- 임시 테이블의 크기가 1GB보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록
  - `internal_tmp_storage_engine` 시스템 변수로 메모리용 임시 테이블을 MEMORY와 TempTable 중 하나를 선택(기본값은 TempTable)
  - `temptable_max_ram` 시스템 변수로 크기 변경 가능
- 임시 테이블을 디스크에 저장하는 방식은 아래 두 가지 중 하나를 선택
  - MMAP 파일을 디스크에 기록
  - InnoDB 테이블로 기록
- 저장 방식은 `temptable_use_mmap` 시스템 변수를 통해 설정(기본값은 ON)
  - TempTable 크기가 1GB를 넘으면 MMAP 파일로 전환
  - MMAP 파일로 전환하는 것이 InnoDB의 테이블로 전환하는 것보다 오버헤드가 적음

### 임시 테이블이 필요한 쿼리
- `ORDER BY`, `GROUP BY`에 명시된 컬럼이 다른 쿼리
- `ORDER BY`, `GROUP BY`에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`나 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`, `UNION DISTINCT`가 사용된 쿼리 (`select_type` 컬럼이 `UNION RESULT`인 경우)
  - `UNION ALL`을 사용하는 쿼리는 MySQL 8.0부터는 임시 테이블을 사용하지 않도록 개선
- 실행 계획에서 `select_type` 컬럼이 `DERIVED`인 경우

### 임시 테이블이 디스크에 생성되는 경우
- `UNION`, `UNION ALL`에서 `SELECT` 되는 컬럼 중에서 길이가 512바이트 이상의 크기의 컬럼이 있는 경우
- `GROUP BY`나 `DISTINCT` 컬럼에서 512바이트 이상의 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 지정된 시스템 변수 값보다 큰 경우

# 고급 최적화
옵티마이저가 실행계획을 수립할 때는 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행계획 수립 

옵티마이저 옵션은 **조인과 관련된 옵티마이저 옵션**과 **옵티마이저 스위치**로 구분

## 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어

![image](https://user-images.githubusercontent.com/59307414/218299446-9ece21ab-d8ee-4040-a2f1-ace7ca067e5e.png)

![image](https://user-images.githubusercontent.com/59307414/218299449-b1856fe6-8481-4b18-9aa2-f51f4d40f2c4.png)

### MRR, 배치 키 엑세스 (mmr, batched_key_access)
#### MMR(Multiple-Range Read)
기존에 MySQL에서 지원하던 조인 방식은 **네스티드 루프 조인**(Nested Loop Join) 방식

- 네스티드 루프 조인은 조인 조건에 일치하는 레코드를 찾기 위해 왼쪽 테이블의 레코드를 하나씩 읽어서 오른쪽 테이블의 레코드를 읽는 방식
- 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인

MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당

- 이 때 드라이빙 테이블의 레코드의 건별로 드리븐 테이블의 레코드를 찾으면 레코드르 찾고 있는 스토리지 엔진에서는 아무런 최적화를 수행할 수 없음

이런 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링

- 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링
- 조인 버퍼에 레코드가 가득차면 MySQL 엔진은 버퍼링된 레코들르 스토리지 엔진에 한 번에 요청

이러한 방식을 MMR이라고 하며, 이를 응용해서 실행되는 조인 방식을 BKA 조인이라고 함

BKA 조인 최적화는 기본적으로 비활성화

- 쿼리의 특성에 따라 BKA 조인이 큰 도움이 되는 경우도 있지만, BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해서 오히려 성능 저하 유발

### 블록 네스티드 루프 조인 (block_nested_loop)
네스티드 루프 조인과 가장 큰 차이는 조인 버퍼(`join_buffer_size`)가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되냐의 차이

- 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 풀 테이블 스캔을 반복적으로 실행
- 드리븐 테이블의 풀 테이블 스캔 또는 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시 후, 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리 -> 이 때 사용하는 메모리 캐시가 조인 버퍼
- 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행
  - 실제 드라이빙 테이블의 결과를 조인 버퍼에 담고, 드리빈 테이블을 먼저읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식
  - 일반적으로는 조인 수행 후에 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 경우 조인의 정렬 순서가 흐트러질 수 있음

조인 알고리즘에서 Block 이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미

조인 쿼리의 실행 계획에서 `Extra` 컬럼에 `Using Join buffer`라고 표시되면 조인 버퍼를 사용하고 있다는 것

8.0.18 버전부터는 해시 조인 알고리즘이 도입되면서 블록 네스티드 루프 조인은 더 이상 사용되지 않음

> 해시 조인
> 
> 해시 조인은 네스티드 루프 조인에 비해 첫 번째 레코드를 찾는 데에 시간이 더 걸리지만 최종 레코드를 찾는데까지는 시간이 많이 걸리지 않음
> 
> - 해시 조인 쿼리는 Beset Throughput에 적합
> - 네스티드 루프 조인은 Best Response Time에 적합
> 
> 일반적인 웹 서비스는 온라인 트랜잭션 서비스이기 때문에 throughput도 중요하지만 response time이 더 중요
> 
> - 조인 조건의 컬럼이 인덱스가 없거나 조인 대상 테이블 중 일부 레코드 건수가 매우 적은 경우에 한해 해시 조인 알고리즘 사용
> - 보통은 네스티드 루프 조인 사용

### 인덱스 컨디션 푸시다운 (index_condition_pushdown)
```mysql
Alter table employees add index ix(first_name, last_name);

select * from employees where first_name ='Acton' and last_name like '%sal';
```

ix(first_name, last_name) 이라는 인덱스가 있을때, last_name like ‘%sal’ 조건은 인덱스를 사용할 수 없는 조건

MySQL 5.5 에서는 MySQL 엔진 → Innodb 스토리지 엔진으로 last_name 은 사용할 수 없는 조건이기에 전달조차 해주지 않음

MySQL 5.6 이후 부터는 인덱스에 있는 컬럼은 모두 Innodb 스토리지 엔진으로 전달

스토리지 엔진단에서 최대한 필터링까지 완료해서 MySQL 엔진으로 전달하게 되는데 이러한 처리 과정을 `Using index condition`

- extra 컬럼에 `Using index condition` 표시

index 조건에 대하여 스토리지 엔진에서 모두 처리하는 방법

### 인덱스 확장 (use_index_extensions)
세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지를 결정하는 옵션

InnoDB 스토리지 엔진에서 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키를 포함

PK가 A, Secondary index가 B라면 실제 Secondary index는 (B, A)로 작동

- 정렬 시에 인덱스를 탄다 -> `Using filesort`가 표시되지 않음

<br/>

### 인덱스 머지 (index_merge)
하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리

where 조건이 여러 개 있더라도 하나의 인덱스에 포함된 컬럼에 대한 조건만으로 인덱스를 검색하고, 나머지 조건은 일겅온 레코드에 대해서 체크하는 형태가 일반적

- 하지만 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, **그 조건을 만족하는 레코드 건수가 많을 때**는 인덱스 머지 실행 계획 선택

인덱스 머지 실행 계획은 3개의 세부 실행 계획으로 나눌 수 있음

- index_merge_intersection
- index_merge_sort_union
- index_merge_union

### 인덱스 머지 - 교집합 (index_merge_intersection)
여러 개의 인덱스를 각각 검색해서 그 결과의 교집합을 반환

실행계획의 extra 칼럼에 `Using intersect` 표시

### 인덱스 머지 - 합집합 (index_merge_union)
여러 개의 인덱스를 각각 검색해서 그 결과의 합집합을 반환

- 중복된 값을 제거할 때에는 Priority queue 를 사용하여 제거

실행계획의 extra 칼럼에 `Using union` 표시

### 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)
union 알고리즘은 두 결과의 집합의 중복을 제거를 위해 정렬된 결과가 필요

만약 인덱스 머지 작업 중에 결과의 정렬이 필요한 경우에는 sort union 알고리즘을 사용

실행계획의 extra 칼럼에 `Using sort_union` 표시

<br/>

### 세미 조인 (semijoin)
다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리

- table pull-out
  - 사용 가능하면 항상 세미 조인보다는 좋은 성능을 내기 때문에 별도로 제어하는 옵티마이저 옵션을 제공하지 않음
- duplicate weed-out
- first match
- loose scan
- materialization

### 테이블 풀-아웃 (table pull-out)
세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화

IN(subquery) 형태의 세미 조인이 가장 빈번하게 사용되는 형태의 쿼리

- IN 형태의 쿼리를 Join 형태로 재작성
- `explain`으로 실행 계획을 확인할 때는 별도로 노출되지 않으며, `SHOW WARNINGS` 커맨드를 통해 확인 가능

### 퍼스트 매치 (first match)
IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행

실행계획의 extra 칼럼에 `FirstMatch()` 표시

### 루스 스캔 (loosescan)
인덱스를 사용하는 GROUP BY 최적화 방법에서 언급된 Loose Index Scan(`Using index for group-by`)과 비슷한 읽기 방식을 사용

실행계획의 extra 칼럼에 `LooseScan` 표시

### 구체화 (materialization)
세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화

- 구체화는 내부 임시 테이블을 만드는 것을 의미

실행계획의 select_type 컬럼에 `MATERIALIZED` 표시

### 중복 제거 (duplicated weed-out)
```mysql
# Expected
select * from employees e
where e.emp_no in (select s.emp_no from salaries s where s.salary > 150000);

# Actual
select e.*
from employees e, salaries s
where e.emp_no = s.emp_no and s.salary > 150000
group by e.emp_no;
```

세미 조인 서브쿼리를 일반적인 Inner Join 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리

- 원본 쿼리를 INNER JOIN + GROUP BY 형태로 변경

실행계획의 extra 칼럼에 `Start temporary`, `End temporary` 표시

- start와 end 구간이 최적화 처리 과정

<br/>

### 컨디션 팬아웃 (condition_fanout_filter)
MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행

- 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미침
- `filtered` : 필터링되고 남은 레코드의 비율을 의미
  - filtered = 12(%) 이란 얘기는 100건의 rows 중에 12 건(=100 * 0.12)만 남고 나머지 88 건은 MySQL 엔진에 의해 필터링 되었다는 것을 의미

옵티마이저는 condition_fanout_filter 최적화 기능을 활성화하여 보다 정교한 계산을 할 수 있음

- WHERE 조건절에 사용된 칼럼에 인덱스가 있는 경우
- WHERE 조건절에 사용된 칼럼에 히스토그램이 존재하는 경우

### 파생 테이블 머지 (derived_merge)
MySQL 5.7버전부터는 파생 테이블(Derived table, FROM 절에 사용된 서브쿼리)로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화 도입

- 예전에는 FROM 절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리
- 예전 버전의 MySQL 서버에서 메모리로 생성되는 임시 테이블은 MEMORY 스토리지 엔진 사용, 디스크에 임시 생성은 MyISAM 스토리지 엔진 사용
  - MEMORY 엔진은 가변 길이 컬럼을 지원하지 않아서 메모리 과다 사용하는 문제, MyISAM은 트랜잭션 미지원 문제
- 8.0부터는 메모리용 임시 테이블에 TempTable 스토리지 엔진, 디스크 임시 생성은 InnoDB 사용

### 인비저블 인덱스 (use_invisible_indexes)
```mysql
ALTER TABLE ... ALTER INDEX ... [ VISIBLE | INVISIBILE ]
```

MySQL 8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능 추가

- 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어할 수 있음

### 스킵 스캔 (skip_scan)
인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요

(A, B, C)로 구성된 인덱스가 있을 때 B와 C 칼럼에 대한 조건을 가지고 있다면 인덱스를 활용할 수 없음

인덱스 스킵 스캔은 제한적이긴 하지만 인덱스의 이러한 제약을 해소하는 최적화 기법

8.0 버전부터 도입, 인덱스의 선행 컬럼이 조건절에 사용되지 않더라도 후행 컬럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선 가능

### 해시 조인 (hash_join)
해시 조인은 네스티드 루프 조인에 비해 첫 번째 레코드를 찾는 데에 시간이 더 걸리지만 최종 레코드를 찾는데까지는 시간이 많이 걸리지 않음

- 해시 조인 쿼리는 Beset Throughput에 적합
- 네스티드 루프 조인은 Best Response Time에 적합

일반적인 웹 서비스는 온라인 트랜잭션 서비스이기 때문에 throughput도 중요하지만 response time이 더 중요

- 조인 조건의 컬럼이 인덱스가 없거나 조인 대상 테이블 중 일부 레코드 건수가 매우 적은 경우에 한해 해시 조인 알고리즘 사용

해시 조인은 빌드 단계와 프로브 단계로 나누어 처리

- 빌드 단계 : 조인 대상 테이블 중에서 레코드 건수가 적은 테이블을 골라서 해시 테이블을 생성하는 작업 수행
- 프로브 단계 : 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정

### 인덱스 정렬 선호 (prefer_ordering_index)
MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행

- 이 가중치를 부여하지 않게 하기위해 prefer_ordering_index 옵션 활용

## 조인 최적화 알고리즘
- Exhausitive Search
- Greedy Search

### Exhaustive 알고리즘
5.0 이전에 사용되던 조인 최적화 기법

FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법

- N! 개의 조합

### Greedy 검색 알고리즘
5.0부터 도입된 조인 최적화 기법

![image](https://user-images.githubusercontent.com/59307414/218309736-4f76fe59-b610-4b56-834d-cc592acf659e.png)

1. 전체 N개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성

2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정

3. 2번에서 선정된 실행 계획의 첫 테이블을 부분 실행 계획의 첫 번째 테이블로 선정

4. 전체 N-1개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성

5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산

6. 5번의 비용 계산 결과 최적의 실행 계획에서 두 번째 테이블을 3번에서 새성된 부분 실행 계획의 두 번째 테이블로 선정

7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 

8. 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정됨

조인 최적화를 위한 시스템 변수

- optimizer_search_depth : Greedy 검색 알고리즘과 Exhaustive 검색 알고리즘 중에서 어떤 알고리즘을 사용할지 결정

- optimizer_prune_level : Heuristic 검색이 작동하는 방식 제어

# 쿼리 힌트
MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못함

따라서 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 방법 필요

- 인덱스 힌트
- 옵티마이저 힌트

## 인덱스 힌트
STRAIGHT_JOIN, USE_INDEX 등의 인덱스 힌트는 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능

SQL 문법에 맞게 사용해야 하기 때문에 사용하는 경우 ANSI-SQL 표준 문법을 준수하지 못함

따라서 가능하면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 권장

인덱스 힌트는 SELECT 명령과 UPDATE 명령에서만 사용 가능

### STRAIGHT_JOIN
```mysql
-- origin
select *
from t1, t2, t3
where ...

-- case1
select straight_join *
from t1, t2, t3
where ...

-- case2
select /*! straight_join */ *
from t1, t2, t3
where ...
```

SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 **조인 순서를 고정**하는 역할

STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트로는 아래의 힌트들이 존재
- JOIN_FIXED_ORDER
- JOIN_ORDER
- JOIN_PREFIX
- JOIN_SUFFIX

### USE INDEX / FORCE INDEX / IGNORE INDEX
```mysql
select * from employees where emp_no=10001;
select * from employees force index (primary) where emp_no=10001;
select * from employees use index (primary) where emp_no=10001;

select * from employees ignore index (primary) where emp_no=10001;
select * from employees force index (ix_firstname) where emp_no=10001;
```

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시

3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우에 가끔 옵티마이저가 실수 할 수 있음

이런 경우 강제로 특정 인덱스를 사용하도록 힌트를 추가

- USE INDEX : 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트
- FORCE INDEX : USE INDEX 와 비슷하지만 더 강하게 사용하도록 요구하는 힌트 (거의 사용하지 않음)
- IGNORE INDEX : 반대로 특정 인덱스를 사용하지 못하게 하는 힌트

인덱스 용도 명시 : 특정 용도로 사용할 수 있게 제한한다.
- USE INDEX FOR JOIN : JOIN 키워드는 JOIN과 레코드 검색까지 포함
- USE INDEX FOR ORDER BY : 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한
- USE INDEX FOR GROUP BY : 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한

### SQL_CALC_FOUND_ROWS
```mysql
select SQL_CALC_FOUND_ROWS * from employees limit 5;
select found_rows() as total_record_count;
```

MySQL의 LIMIT을 사용하는 경우, 조건을 만족하는 레코드가 LIMIT에 명시된 수보다 더 많더라도 명시된 수만큼 만족하는 레코드를 찾으면 즉시 검색을 멈춤

하지만 SQL_CALC_FOUND_ROWS 힌트가 포함된 쿼리는 LIMIT을 만족하는 수만큼 레코드를 찾았더라도 끝까지 검색을 수행

## 옵티마이저 힌트
옵티마이저 힌트는 영향 범위에 따라 다음 4개 그룹으로 나눌 수 있음

- 인덱스 : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트, 힌트가 명시된 쿼리 블록에 대해서만 영향을 끼침
- 글로벌 : 전체 쿼리에 대해서 영향을 미치는 힌트

### MAX_EXECUTION_TIME
쿼리의 최대 실행 시간을 설정하는 힌트

지정된 시간을 초과하면 에러 발생 (ERROR 3024)

영향범위 : 글로벌

### SET_VAR
쿼리 실행을 위한 시스템 변수 제어

실행 계획을 바꾸는 용도뿐만 아니라 조인 버퍼나 정렬용 버퍼의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로도 사용할 수 있음

영향범위 : 글로벌

### SEMIJOIN, NO_SEMIJOIN
서브쿼리의 세미 조인 최적화 전략 제어

- ~~table pull-out~~ : 디폴트로 적용되기 때문에 없음
- duplicate weed-out : `SEMIJOIN(DUPSWEEDOUT)`
- first match : `SEMIJOIN(FIRSTMATCH)`
- loose scan : `SEMIJOIN(LOOSESCAN)`
- materialization : `SEMIJOIN(METERIALIZATION)`

영향범위 : 쿼리 블록

### SUBQUERY
세미 조인 최적화가 사용되지 못할 때 사용하는 방법

- IN-to-EXIIST : `SUBQUERY(INTOEXISTS)`
- Materialization : `SUBQUERY(MATERIALIZATION)`

영향범위 : 쿼리블록

### BNL, NO_BNL, HASHJOIN, NO_HASHJOIN
블록 네스티드 루프, 해시 조인 알고리즘 적용

영향 범위 : 쿼리 블록, 테이블

### JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX
조인 순서를 결정하는 힌트

- JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일
- JOIN_ORDER : FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 수행
- JOIN_PREFIX : 드라이빙 테이블만 강제
- JOIN_SUFFIX : 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제

영향 범위 : 쿼리 블록

### MERGE, NO_MERGE
FROM 절에 사용된 서브쿼리(혹은 뷰)를 내부 임시 테이블로 생성할지 외부 쿼리와 병합하는 최적화를 수행할지를 정하는 힌트

영향 범위 : 테이블

### INDEX_MERGE, NO_INDEX_MERGE
인덱스 병합 실행 계획 사용 여부 제어

영향 범위 : 테이블, 인덱스

### NO_ICP
ICP(Index condition pushdown) 사용 여부 제어

보통은 항상 성능 향상에 도움되기 때문에 별도로 제어하지 않음

영향 범위 : 테이블, 인덱스

### SKIP_SCAN, NO_SKIP_SCAN
인덱스 스킵 스캔 사용 여부 제어

영향 범위 : 테이블, 인덱스

### INDEX, NO_INDEX
인덱스 힌트를 대체하는 용도로 제공