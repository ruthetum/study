# Chapter09. 옵티마이저와 힌트

# 옵티마이저 (Optimizer)
실제로 **SQL문을 실행하기 전**에 비용 기반으로 다양한 **최적의 실행계획을 세우고 결정**하는 작업 담당

## 쿼리 실행 절차

![image](https://user-images.githubusercontent.com/59307414/209309738-a7ab737a-3551-4ffd-9838-64c989f36d6c.png)

- 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계정보를 참조하며 최적의 실행 계획을 수립하는 역할
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

## 옵티마이저의 종류
> - 규칙 기반 최적화(Rule-based optimizer, RBO): 테이블의 레코드, 분포도를 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립 -> 안 씀
> - 비용 기반 최적화(Cost-based optimizer, CBO): 각 단위 작업의 비용(부하) 정보를 고려하여 실행 계획 비용 산출, 산출된 비용이 최소로 소요되는 처리 방식을 선택

- MySQL의 옵티마이저는 아래와 같은 통계 정보를 통해 비용 기반 최적화를 수행
  - 대략의 레코드 건수
  - 인덱스의 유니크한 값의 개수

# 데이터 처리 방법
## 풀 테이블 스캔과 풀 인덱스 스캔
> - 풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식
> - 풀 인덱스 스캔: 인덱스 리프 블록 처음부터 끝까지 수평적으로 읽는 방식

### 퓰 테이블 스캔이 선택되는 조건
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - 일반적으로 테이블이 페이지 1개로 구성된 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
  - 인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준

### 풀 테이블 스캔 실행
풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드(클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업 백그라운드 스레드로 넘김

- 일반적으로 테이블의 전체 크기가 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 매우 큰 디스크 읽기 작업이 필요
  - 그래서 대부분 DBMS는 풀 테이블 스캔 실행 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능 내장
- 하지만 MySQL에는 풀 테이블 스캔 실행 시 한 번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수가 없음
  - 그래서 간혹 MySQL에서 풀 테이블 스캔 실행 시 디스크로부터 페이지를 하나씩 읽어 오는 것으로 오인하는 경우 존재
- InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(read ahead) 작업이 자동으로 시작
  - 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것
- 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개의 페이지를 읽으면서 계속 수를 증가시키
  - 한 번에 최대 64개의 페이지까지 읽어서 버퍼 풀에 저장
  - 포그라운드 스레드는 버퍼 풀에 저장된 데이터를 읽음
- `innodb_read_ahead_threshold` 시스템 변수를 이용하여 리드 어헤드의 임계값 설정 가능
- 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용

    ```mysql
    SELECT COUNT(*) FROM tbl
    ```

  - 위 쿼리는 아무런 조건이 없기 때문에 풀 테이블 스캔을 할 것처럼 보이지만 실제 실행계획은 풀 인덱스 스캔을 선택
    - 테이블을 전체 조회하는 것보다 인덱스만을 조회하는 것이 용량이 적기 때문
  - 하자만 `SELECT * FROM tbl` 이런 형태로 레코드에 있는 컬럼의 정보를 조회하는 경우에는 풀 인덱스 스캔을 사용하지 못 하고 풀 테이블 스캔 적용

## 병렬 처리
> 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것

- `innodb_parallel_read_threads` 시스템 변수를 이용하여 하나의 쿼리를 여러 개의 스레드를 이용해서 처리할 수 있음
- 병렬 처리용 스레드 개수가 증가시키는 경우 쿼리 처리 시간이 감소 (일부 성능 향상)
  - 하지만 스레드 개수를 아무리 늘리더라도 서버에 정착된 CPU의 코어 개수를 넘어서는 경우 오히려 성능 저하 발생할 수 있음

## ORDER BY 처리 (Using filesort)
- 레코드 1-2건을 가져오는 쿼리가 아닌 이상 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 Filesort를 이용하는 방법으로 나눌 수 있음

|    정렬 방법    | 장점                                                                                            | 단점                                                                                                                                   |
|:-----------:|-----------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
|   인덱스 이용    | INSERT, UPDATE, DELETE가 실행될 때 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되기 때문에 빠름                             | INSERT, UPDATE, DELETE가 실행될 때 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림.<br/>인덱스 때문에 디스크 공간이 더 많이 필요하고, 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 더 많이 필요 |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스와 관련된 추가 작업이 필요하지 않음<br/>정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리하므로 속도가 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느려짐                                                                                  |
- filesort를 이용하는 경우 실행 계획의 `extra` 컬럼에서 `Using filesort` 메세지를 통해 사용 여부 확인
  - `Using filesort`: `ORDER BY` 작업 시 인덱스를 사용하지 못했음을 의미

### 소트 버퍼
- 정렬을 수행하기 위해 별도의 메모리 공간
  - 세션 메모리 영역에 할당 -> 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아님
- 정렬이 필요한 경우에만 할당되며 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가
- `sort_buffer_size` 시스템 변수로 최대 사용 가능한 버퍼의 크기를 설정할 수 있음
- 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되는 순간 시스템으로 반납

> 만약 정렬해야 할 레코드의 건수가 소프 버퍼로 할당된 공간보다 크다면?
- 정렬해야 할 레코드를 여러 조각으로 나눠서 처리
  - 이 과정에서 임시 저장을 위해 디스크를 사용
- 메모리의 소트 버퍼에서 정렬 수행 -> 결과를 임시 디스크에 저장 -> 다음 레코드를 가져와서 다시 정렬 수행 -> 저장하는 과정을 반복
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행
  - 이 병합 작업을 멀티 머지(multi merge)라고 표현
  - 수행된 멀티 머지 횟수는 `sort_merge_passes` 상태 변수에 누적해서 집계
- 결국 이 작업들이 디스크의 쓰기/읽기를 유발하고, 레코드 건수가 많을수록 반복 작업의 횟수가 증가
  - 소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 성능이 개선될 수 있다고 생각할 수 있지만 실제 벤치마크 결과를 확인해보면 별 차이 없음
    - 빠른 성능을 얻을 수는 없지만 디스크의 읽기/쓰기 사용량은 줄일 수 있음
  - 오히려 소트 버퍼 사이즈(`sort_buffer_size`)를 너무 크게 설정하면 큰 메모리 공간 할당으로 인해 오히려 성능 저하
- 일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB에서 1MB 미만이 적절함

### 정렬 알고리즘
|         정렬 모드          | 설명                                                                       | 효율적인 상황                  |
|:----------------------:|--------------------------------------------------------------------------|--------------------------|
| 싱글 패스<br>(Single-pass) | SELECT 대상이 되는 컬럼을 전부 담아서 정렬을 수행하는 방식<br/>(정렬이 필요하지 않은 컬럼까지 모두 읽음)        | 정렬 대상 레코드의 크기나 건수가 작은 경우 |
|   투 패스<br>(Two-pass)   | 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 원하는 컬럼을 조회 | 정렬 대상 레코드의 크거나 건수가 많은 경우 |

#### 싱글 패스 vs 투 패스

- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 비효율적, 따라서 일반적으로 싱글 패스 방식을 이용
- 하지만 싱글 패스 방식은 투 패스 방식에 비해 더 큰 소트 버퍼가 필요하므 아래의 상황에서는 투 패스 방식을 이용
  - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
  - BLOB이나 TEXT 컬럼이 SELECT 대상에 포함될 때

### 정렬 처리 방법
- `ORDER BY` 작업 시 아래 3가지 처리 방법 중 하나로 정렬이 처리됨
  - 표에서 아래 쪽으로 내려갈수록 처리 속도가 떨어짐

|          정렬 처리 방법           | 실행 계획의 `extra` 컬럼 내용                 |
|:---------------------------:|--------------------------------------|
|         인덱스를 이용한 정렬         | 별도 표기 없음                             |
|      조인에서 드라이빙 테이블만 정렬      | `Using filesort` 표기                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | `Using temporary; Using filesort` 표기 |

- 인덱스를 사용할 수 없는 경우 레코드를 검색해 정렬 버퍼에 저장하면서 정렬 처리(filesort)
- 이 때 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 아래 2가지 방법 중 하나를 선택
  - 조인의 드라이브 테이블만 정렬한 다음 조인을 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행
- 일반적으로 조인이 수행되면 레코드 크기가 커지기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적

> Nested Loop, Driving/Driven table
> - NESTED LOOP JOIN은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 조인 방식
> - https://coding-factory.tistory.com/756

#### 인덱스를 이용한 정렬
- 반드시 `ORDER BY`에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, `ORDER BY`의 순서대로 생성된 인덱스가 있어야 함
- 인덱스를 이용한 정렬이 처리되는 경우 실제 인덱스 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 됨
  - MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않음

#### 조인에서 드라이빙 테이블만 정렬
- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행
- 조인에서 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 `ORDER BY` 절을 작성
  - 드리븐 테이블의 컬럼이 `ORDER BY` 절에 작성되어 있으면 조인 전에 정렬이 불가능

#### 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
- 조인 후 결과를 임시 테이블에 저장
  - 인덱스를 이용하거나 드라이빙 테이블을 이용하여 정렬하는 경우 임시 테이블이 필요하지 않음
- 3가지 정렬 방법 중 정렬해야할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법


### 스트리밍 방식 vs 버퍼링 방식
- 보통 웹 서비스용 쿼리에서는 `ORDER BY`와 함께 `LIMIT`이 거의 필수로 사용
- `ORDER BY`, `GROUP BY` 같은 작업은 `WHERE`조건을 만족하는 레코드를 `LIMIT` 건수만큼 가져와서 처리할 수 없음
  - 우선 조건을 만족하는 모든 레코드를 가져와서 정렬 또는 그룹핑해야 함
- `WHERE` 조건이 아무리 인덱스를 잘 활용해도 `ORDER BY`, `GROUP BY`를 잘못 사용하는 경우 쿼리 속도가 느려질 수 있음

#### 스트리밍 방식
- 서버 쪽에서 처리할 데이터 수에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트로 전송해주는 방식
- 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있음
- `LIMIT`처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있음
- 정렬 처리 방법 중 **인덱스를 사용한 방법**에 해당

#### 버퍼링 방식
- `ORDER BY`나 `GROUP BY`같은 처리는 쿼리의 결과를 스트리밍 방식으로 처리할 수 없음
- 모든 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 함
- `LIMIT`처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음
- 정렬 처리 방법 중 **조인에서 드라이빙 테이블만 정렬**, **조인에서 조인 결과를 임시 테이블로 저장 후 정렬**에 해당

## GROUP BY 처리
- `ORDER BY`와 마찬가지로 `GROUP BY` 또한 스트리밍 처리를 할 수 없는 방식
- `GROUP BY`절이 있는 쿼리에서는 필터링 역할을 하는 `HAVING`절을 사용할 수 있음
  - `GROUP BY`에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 `HAVING`절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없음
- `GROUP BY` 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 분류 가능
  - 인덱스를 사용하는 경우: 인덱스를 차례 대로 읽는 스캔(타이트 인덱스 스캔), 루스 인덱스 스캔
  - 인덱스를 사용하지 못 하는 경우: 임시 테이블 사용

|  정렬 처리 방법  | 실행 계획의 `extra` 컬럼 내용                     |
|:----------:|------------------------------------------|
| 타이트 인덱스 스캔 | 별도 표기 없음                                 |
| 루스 인덱스 스캔  | `Using index for group by` 표기 |
| 임시 테이블 사용  | `Using temporary` 표기       |

### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- `ORDER BY`와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑 할 때 `GROUP BY` 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리
  - `GROUP BY`가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹 값을 처리해야 해서 임시 테이블이 필요할 때도 있음

### 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 실행 계획의 `extra` 컬럼에 `Using index for group by` 표기
- 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용할 수 있음
  - 추가로 프리픽스 인덱스(컬럼값의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없음
- 일반적으로 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록(커디널리티가 높을수록) 성능이 향상되지만, 루스 인덱스 스캔은 인덱스의 유니크한 값의 수가 적을수록(커디널리티가 낮을수록) 성능이 향상

#### 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
```mysql
# MIN(), MAX() 이외의 집합 함수가 사용되는 경우
SELECT col1, SUM(col2) FROM tbl GROUP BY col1;

# GROUP BY에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않은 경우
SELECT col1, col2 FROM tbl GROUP BY col2, col3;

# SELECT 절의 컬럼이 GROUP BY와 일치하지 않은 경우
SELECT col1, col3 FROM tbl GROUP BY col1, col2;
```

### 임시 테이블을 사용하는 GROUP BY
- `GROUP BY`의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 임시 테이블을 활용
- 실행 계획의 `extra` 컬럼에 `Using temporary` 표기

> `ORDER BY NULL`
- 5.7 버전까지는 `GROUP BY`가 사용되면 자동으로 그룹핑 컬럼을 기준으로 정렬 수행
  - 정렬이 필요하지 않는 경우 `ORDER BY NULL`을 추가로 작성할 것을 권장
  - `ORDER BY NULL`이 사용되면 MySQL 서버는 불필요한 추가 정렬 작업을 수행하지 않으므로 일정 부분 성능 향상
- 8.0 버전부터는 `GROUP BY`를 사용하더라도 묵시적인 정렬이 수행되지 않기 때문에 정렬된 결과가 필요하지 않은 경우 굳이 `ORDER BY NULL`을 추가할 필요 없음

## DISTINCT 처리
- `DISTINCT`는 `MIN()`, `MAX()`, `COUNT()` 같은 집합함수와 함께 사용되는 경우와 집합 함수가 없는 2가지 경우로 구분
  - 위의 경우에 따라 `DISTINCT` 키워드의 영향 범위가 달라짐
  - 집합 함수와 같이 `DISTINCT`가 사용되는 경우 실행 계획에서 `DISTINCT` 처리가 인덱스를 사용하지 못할 때는 임시 테이블이 필요
    - 하지만 실행 계획의 `extra` 컬럼에는 `Using temporary`가 표기되지 않음

### SELECT DISTINCT ...
- 단순 `SELECT` 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 `SELECT DISTINCT` 형태의 쿼리 문장을 사용
  - 이 경우에는 `GROUP BY`와 동일한 방식으로 처리
    
    ```mysql
    # 두 쿼리는 내부적으로 같은 작업을 수행
    SELECT DISTINCT emp_no FROM tbl;
    SELECT emp_no FROM tbl GROUP BY emp_no;
    ```

- `DISTINCT`는 `SELECT`하는 레코드 유니크하게 조회하는 것이지, 특정 컬럼만 유니크하게 조회하는 것이 아님

  ```mysql
  # 특정 컬럼이 아닌 컬럼의 조합을 기준으로 유니크한 레코드를 조회
  # 아래 두 쿼리는 같은 결과 반환
  SELECT DISTINCT col1, col2 FROM tbl;
  SELECT DISTINCT(col1), col2 FROM tbl; # 괄호는 의미 없음, 파서에서 괄호 제거(의미없는 구문)
  ```

### 집합 함수와 함께 사용되는 DISTINCT
- `MIN()`, `MAX()`, `COUNT()` 같은 집합 함수에서 `DISTINCT` 키워드를 사용하면 ₩`SELECT DISTINCT`와 다른 형태로 해석
  - 집합 함수가 없을 때는 `DISTINCT`는 조회하는 모든 컬럼의 조합이 유니크한 것만 조회
  - 집합 함수가 있을 때는 `DISTINCT`는 그 집함 함수의 인자로 전달된 컬럼값이 유니크한 것을 조회
- 쿼리의 실행 계획에서 `DISTINCT`가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요
  - 하지만 실행 계획의 `extra` 칼럼에는 `Using temporary` 메세지가 표기되지 않음


## 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드들을 정렬하거나 그룹핑 할 때는 내부적인 임시 테이블을 사용
  - `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블과 다름
- 내부적인 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨짐
- 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제

### 메모리 임시 테이블과 디스크 임시 테이블
- 8.0 이전 버전까지는 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하고, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 사용
- 8.0 버전부터는 메모리는 기본값으로 TempTable 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선
  - MEMORY 테이블은 `VARBINARY`, `VARCHAR` 등 가변 길이 타입을 지원하지 못해 메모리 낭비가 심해지는 문제점이 존재 → TempTable 스토리지 엔진은 가변 길이 타입을 지원
  - MyISAM 테이블은 트랜잭션을 지원하지 못함 → InnoDB 스토리지 엔진은 트랜잭션을 지원
- 임시 테이블의 크기가 1GB보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록
  - `internal_tmp_storage_engine` 시스템 변수로 메모리용 임시 테이블을 MEMORY와 TempTable 중 하나를 선택(기본값은 TempTable)
  - `temptable_max_ram` 시스템 변수로 크기 변경 가능
- 임시 테이블을 디스크에 저장하는 방식은 아래 두 가지 중 하나를 선택
  - MMAP 파일을 디스크에 기록
  - InnoDB 테이블로 기록
- 저장 방식은 `temptable_use_mmap` 시스템 변수를 통해 설정(기본값은 ON)
  - TempTable 크기가 1GB를 넘으면 MMAP 파일로 전환
  - MMAP 파일로 전환하는 것이 InnoDB의 테이블로 전환하는 것보다 오버헤드가 적음

### 임시 테이블이 필요한 쿼리
- `ORDER BY`, `GROUP BY`에 명시된 컬럼이 다른 쿼리
- `ORDER BY`, `GROUP BY`에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`나 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`, `UNION DISTINCT`가 사용된 쿼리 (`select_type` 컬럼이 `UNION RESULT`인 경우)
  - `UNION ALL`을 사용하는 쿼리는 MySQL 8.0부터는 임시 테이블을 사용하지 않도록 개선
- 실행 계획에서 `select_type` 컬럼이 `DERIVED`인 경우

### 임시 테이블이 디스크에 생성되는 경우
- `UNION`, `UNION ALL`에서 `SELECT` 되는 컬럼 중에서 길이가 512바이트 이상의 크기의 컬럼이 있는 경우
- `GROUP BY`나 `DISTINCT` 컬럼에서 512바이트 이상의 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 지정된 시스템 변수 값보다 큰 경우

# 고급 최적화
## 옵티마이저 스위치 옵션

### MRR, 배치 키 엑세스 (mmr, batched_key_access)

### 블록 네스티드 루프 조인 (block_nested_loop)

### 인덱스 컨디션 푸시다운 (index_condition_pushdown)

### 인덱스 확장 (use_index_extensions)

### 인덱스 머지 (index_merge)

### 인덱스 머지 - 교집합 (index_merge_intersection)

### 인덱스 머지 - 합집합 (index_merge_union)

### 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)

### 세미 조인 (semijoin)

### 테이블 풀-아웃 (table pull-out)

### 퍼스트 매치 (first match)

### 루스 스캔 (loosescan)

### 구체화 (materialization)

### 중복 제거 (duplicated weed-out)

### 컨디션 팬아웃 (condition_fanout_filter)

### 파생 테이블 머지 (derived_merge)

### 인비저블 인덱스 (use_invisible_indexes)

### 스킵 스캔 (skip_scan)

### 해시 조인 (hash_join)

### 인덱스 정렬 선호 (prefer_ordering_index)

## 조인 최적화 알고리즘
### Exhaustive 알고리즘

### Greedy 검색 알고리즘

# 쿼리 힌트


## 인덱스 힌트
### STRAIGHT_JOIN

### USE INDEX / FORCE INDEX / IGNORE INDEX

### SQL_CALC_FOUND_ROWS

## 옵티마이저 힌트

### 힌트 종류


|힌트 이름|설명|영향 범위|
|---|---|---|
|||

### MAX_EXECUTION_TIME

### SET_VAR

### SEMIJOIN, NO_SEMIJOIN

### SUBQUERY

### BNL, NO_BNL, HASHJOIN, NO_HASHJOIN

### JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX

### MERGE, NO_MERGE

### INDEX_MERGE, NO_INDEX_MERGE

### NO_ICP

### SKIP_SCAN, NO_SKIP_SCAN

### INDEX, NO_INDEX