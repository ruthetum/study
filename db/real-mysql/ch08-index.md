# Chapter08. 인덱스

- [1. 디스크 읽기 방식](#1-디스크-읽기-방식)
- [2. 인덱스란](#2-인덱스란)
- [3. B-Tree 인덱스](#3-B-Tree-인덱스)
- [4. R-Tree 인덱스](#4-R-Tree-인덱스)
- [5. 전문 검색 인덱스](#5-전문-검색-인덱스)
- [6. 함수 기반 인덱스](#6-함수-기반-인덱스)
- [7. 멀티 밸류 인덱스](#7-멀티-밸류-인덱스)
- [8. 클러스터링 인덱스](#8-클러스터링-인덱스)
- [9. 유니크 인덱스](#9-유니크-인덱스)
- [10. 외래키](#10-외래키)

---

## 1. 디스크 읽기 방식
- 결국 DB 성능 튜닝은 어떻게 디스크 I/O를 줄이냐가 관건
  - 그 관점에서 I/O 방식과 저장장치에 대해 간단한 이해 필요

- 대부분의 DBMS는 SSD 채택
    - HDD보다 빠르다

- I/O 방식은 랜덤 I/O, 순차 I/O 존재
  - SSD의 장점은 HDD보다 랜덤 I/O에서 이점이 존재

## 2. 인덱스란
- 책 끝에 있는 '찾아보기'(또는 색인)으로 이해
  - '찾아보기'를 통해 데이터 파일에 해당되는 책의 내용을 찾아갈 수 있음

- 인덱스는 SortedList 형태라고 생각하면 됨
  - 저장되는 컬럼의 값을 정렬된 상태로 유지
  - 쓰기 성능은 떨어질 수 있으나, 읽기 성능이 좋음
    - 일반적인 서비스에서 쓰기/읽기 비율이 1:9, 2:8이다보니 읽기 성능에 집중

- 데이터 저장 방식은 다양하게 분류할 수 있지만 대표적으로는 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있음
    - B-Tree 알고리즘: 컬럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘 (R-Tree 인덱스는 B-Tree의 응용 알고리즘)
    - Hash 인덱스 알고리즘: 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알로기즘으로 빠른 검색을 지원, 주로 메모리 기반의 DB에서 많이 사용

## 3. B-Tree 인덱스
B-Tree의 B는 Balanced를 의미

### 구조 및 특성
- 최상위에 하나의 **루트 노드**가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 **리프 노드**라 하고, 중간에 있는 노드를 **브랜치 노드**라고 함
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되고, 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소값을 저장

### B-Tree 인덱스 키 추가 및 삭제
**인덱스 추가**
- B-Tree에 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색하고, 이를 통해 B-Tree의 리프 노드에 저장
- 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리(split)되어야 하는데, 이는 상위 브랜치 노드까지 같이 처리되어야 함
- 따라서 B-Tree는 쓰기 작업 시 비용이 더 많이 발생
  - 대략적으로 테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면, 인덱스에 키를 추가하는 작업 비용은 1.5 정로 예측

**인덱스 삭제**
- B-Tree에서 키 값이 삭제할 때는 해당 키 값이 저장된 리프 노드를 찾아서 삭제함

**인덱스 변경**
- 삭제하고, 추가하는 작업으로 처리

**인덱스 키 검색**
- 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE, DELETE를 처리할 때도 사용
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우 사용 가능
  - 부등호 비교 조건에서도 활용할 수 있지만 인게슬르 구성하느 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없음
  - 인덱스 키 값에 변형이 가해지면 인덱스를 이용하는 B-Tree의 빠른 검색 기능을 이용할 수 없음
- InnoDB에서는 레코드 잠금 또는 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있기 때문에 인덱스 설정이 없으면 불필요하게 많은 레코드를 잠금

### B-Tree 인덱스 사용에 영향을 미치는 요소
**인덱스 키 값의 크기**
- InnoDB에서는 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 함
  - 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
- 인덱스의 크기가 커지면 정해진 인덱스 페이지에 저장되는 키의 수가 감소
  - 이는 인덱스 값이 커지면 커질수록 디스크로부터 읽어야 하는 횟수가 증가하고, 그만큼 느려짐을 의미

**B-Tree의 깊이**
- 인덱스의 깊이는 중요하지만 직접 제정할 수 있는 방법은 없음
- 당연히 깊이가 얕을수록 좋고, 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋음
- 아무리 대용량 데이터베이스라도 깊이는 5단계 이상까지 깊어지는 경우는 흔치 않음

**선택도(기수성)**
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고, 선택도 또한 떨어짐
- 선택도가 높을수록 검색 대상이 줄어들고 그만큼 빠르게 처리됨

**읽어야 하는 레코드의 건수**
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
  - 테이블에 레코드가 100만건이 저장되어 있을 때 50만건을 읽어야 하는 쿼리가 있을 때 어떤 방법이 효율적일까?
    - 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 방법
    - 인덱스를 통해 필요한 50만 건만 읽어오는 방법

- 일반적으로 인덱스를 통해 레코드 1건을 읽는 것은 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 비용이 더 큼
  - 따라서 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 직접 읽어서 필터링하는 방식이 효율적임
  - 검색할 데이터가 많다면 인덱스를 이용하여 작업 범위를 줄이는 것이 무조건 좋지는 않음

### B-Tree 인덱스를 통한 데이터 읽기
**인덱스 레인지 스캔**
- 인덱스 접근 방법 중 가장 대표적인 접근 방식
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
  - 시작해야할 위치를 찾으면 그 때부터는 리프 노드의 레코드만 순서대로 읽음
  - 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아가서 다시 스캔
  - 최종 스캔 위치에 다다르면 지금까지 읽은 레코드를 반환
- 리프 노드 간의 링크를 이용해 다음 리프 노드로 이동하기 때문에 랜덤 I/O가 발생하고, 이 때문에 읽어야 할 레코드가 전체 레코드의 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 효율적임

**인덱스 풀 스캔**
- 인덱스의 처음부터 끝까지 읽는 방식을 인덱스 풀 스캔이라고 함
- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식을 사용
  - 인덱스가 (A, B, C) 순서로 만들어졌을 때 B 또는 C 컬럼으로 검색하는 경우
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작기 때문에 테이블을 직접 읽는 것보다는 인덱스만 읽는 것이 효율적임
  - 다만 쿼리가 인덱스에 명시된 컬럼만으로 처리할 수 없는 경우에는 이 방식으로 처리되지 않음

**루스(Loose) 인덱스 스캔**
- 오라클의 '인덱스 스킵 스캔'이라는 하는 기능과 유사
- 인덱스 레인지 스캔과 인덱스 풀 스캔과 상반된 의미로 타이트 인덱스 스캔으로 분류
  - 말 그대로 느슨하게 듬성듬성 인덱스를 읽음
- 기본적으로 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요하지 않는 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어감
- 일반적으로 `GROUP BY` 또는 집합 함수 가운데 `MAX()`, `MIN()` 함수에 대해서 최적화하는 경우에 사용

**인덱스 스킵 스캔**
```mysql
# 인덱스 설정
ALTER TABLE employees ADD INDEX ix_gender_birthdate (gender, birth_date);

# 인덱스를 사용하지 못하는 쿼리
SELECT * FROM employees WHERE birth_date >= '1998-01-17';

# 인덱스를 사용할 수 있는 쿼리
SELECT * FROM employees WHERE gender = 'M' AND birth_date >= '1998-01-17';
```
- gender 컬럼과 birht_date 컬럼의 조건을 가진 두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있지만 gender 컬럼에 대한 비교 조건이 없는 첫 번째 쿼리는 인덱스를 사용할 수 없음
  - 이 경우에는 birth_date 컬럼부터 시작하는 인덱스를 새로 생성해줘야 함
- 하지만 MySQL 8.0부터는 옵티마이저가 gender 컬럼을 건너뛰어서 birth_date 컬럼만으로도 인덱스 검색이 간으하게 해주는 인덱스 스킵 스캔 기능 도입
  - 루스 인덱스 스캔은 `GROUP BY` 작업을 처리하기 위해 인덱스를 사용하는 경우에 적용할 수 있음
  - 인덱스 스킵 스캔은 `WHERE` 절 검색을 위해 사용 가능하도록 용도가 확장됨
- 인덱스 스킵 스캔은 8.0 버전에 새로 도입된 기능이어서 아직 아래와 같은 단점이 존재
  - `WHERE` 절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)
- 즉, 인덱스 스킵 스캐은 인덱스의 선행 컬럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화

### 다중 컬럼 인덱스
- 두 개 이상의 컬럼으로 구성된 인덱스 (= 복합 인덱스)
- 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되기 때문에 인덱스의 순서가 중요함

### B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 오름차순 또는 내림차순으로 정렬되어 저장
  - 인덱스가 오름차순으로 생성됐다고 해서 무조건 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아님
  - 거꾸로 읽으면 내림차순으로 정렬된 인덱스로 활용 가능
- 하지만 인덱스를 정순으로 읽느냐, 역순으로 읽느냐에 따라 성능 차이가 발생
- InnoDB 구조상 인덱스 역순 스캔은 인덱스 정순 스캔에 비해 느림
  - 페이지의 잠금이 인덱스 정순 스캔에 적합한 구조
  - 페이지 내에서 인덱스 레코드가 단방향으로 연결된 구조

### B-Tree 인덱스의 가용성과 효율성
- 인덱스의 순서에 따라 읽어야 하는 데이터의 범위가 달라짐
- 인덱스 설정 및 쿼리 조건에 따라 작업 범위 결정 조건을 감소할 수도 있고, 단순히 필터링 조건으로 활용될 수 있음
  - 작업 범위 결정 조건을 줄이야 데이터를 읽는 범위가 줄어들기 때문에 이를 인지해서 인덱스를 사용해야 함

## 4. R-Tree 인덱스
- 공간 인덱스(Spatial Index)는 R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스
  - 12.2절 공간 검색에서 자세히 나옴
- 일반적으로 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용
  - `ST_Contains()` 또는 `ST_Within()` 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에 인덱스를 이용할 수 있음
  - ex. 특정 지점을 기준으로 사각 박스 이내의 위치를 검색 (반경 5km 이내 검색)

## 5. 전문 검색 인덱스
- B-Tree 인덱스는 실제 컬럼의 값이 1MB이더라도 1MB 전체의 값을 인덱스 키로 사용하지 않고, 1000바이트(MyISAM) 또는 3072바이트(InnoDB)까지만 잘라서 인덱스 키로 사용
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 FTS(Full Text Search)에는 InnoDB, MyISAM 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없음
- 5.7버전부터 InnoDB에서 FTS를 지원, 8.0버전부터는 InnoDB가 기본 스토리지 엔진이 되면서 InnoDB 엔진 중심으로 개선되기 때문에 InnoDB를 기준으로 확인

### 인덱스 알고리즘
- 빠르게 검색하기 위해 사용자가 검색하게 될 키워드를 분석하고 해당 키워드로 인덱스 구축
- 키워드 분석 및 인덱스 구축에는 여러 가지 방법이 존재
  - **어근 분석**
  - **n-gram 분석**
  - 과거에는 구분자(공백, 일부 문장 기호를 기준으로 토큰 분리)도 하나의 인덱싱 알고리즘으로 생각됐지만 8.0버전부터 위 방법들에 함께 포함되기 때문에 별도 언급 X

**어근 분석**
- MySQL 서버의 전문 검색 인덱스는 아래 두 가지 과정을 거쳐 색인 과정 수행
  - 불용어 처리
  - 어근 분석

- 불용어 처리는 검색에 가치가 없는 단어를 필터링해서 제거하는 작업
  - 불용어의 수가 많지 않기 때문에 알고리즘을 구현한 코드에 상수로 정의해서 사용하는 경우가 많음
  - 유연성을 위해 불용어 자체를 데이터베이스화해서 사용자가 추가하거나 삭제할 수 있게 구현하는 경우도 존재
  - MySQL 서버에 불용어가 정의되어있지만, 보통은 사용자가 별도로 불용어를 정의하여 사용

- 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
  - MySQL 서버는 MeCab을 플러그인 형태로 사용할 수 있게 지원
    - [MeCab](https://taku910.github.io/mecab/) : 오픈 소스 형태소 분석 라이브러리
  - 한글이나 일본어의 경우 영어와 같이 단어의 변형 자체가 없기 때문에 문장의 형태소를 분석해서 명사와 조사를 구분하는 것이 중요
  - 서구권 언어를 위한 형태소 분석기에는 MongoDB에서 사용되는 [Snowball](https://snowballstem.org/)도 존재
- 결국 한국어 기준으로 생각해보면 형태소 분석을 통해 명사를 추출하고 저장
- 다만 한글 또는 특정 언어에 맞게 완성도를 갖추는 작업에 많은 시간과 노력이 필요

**n-gram 알고리즘**
- 어근 분석의 경우 범용적으로 적용하기에 어려움이 있기 때문에 이를 보완하기 위한 n-gram 알고리즘이 도입
- n-gram은 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법
  - n은 인덱싱할 키워드의 최소 글자수를 의미
  - 일반적으로 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram(bi-gram) 방식을 많이 사용
- 띄어쓰기와 마침표를 기준으로 단어를 구분하고, n글짜씩 중첩해서 토큰으로 분리
- 분리된 토큰들에 대해 불용어를 걸러내는 작업 수행
  - 불용어와 동일하거나 불용어를 포함하는 경우 필터링
- 이후 걸러진 토큰들을 인덱스로 등록

```
# 예시 문장
To be or not be. That is the question
```
```
# 토큰 분리
To / be / or / no / ot / to / be / Th / ha / at / is / th / he
qu / ue / es / st / ti / io / on
```
```
# 불용어 처리 후 인덱스 등록
et / he / no / ot / qu / st / Th / th / ue
```

**불용어 변경 및 삭제**
- 스토리지 엔진에 관계 없이 모든 전문 검색 인덱스에 대한 불용어를 제거하는 방법
  - MySQL 서버의 설정 파일(my.cnf)의 `ft_stopword_file` 시스템 변수에 빈 문자열 입력
    - https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_ft_stopword_file
  - 다만 MySQl 서버가 시작될 때만 해당 값을 인지하기 때문에 설정을 변경하는 경우 MySQL 서버를 재시작해야함
  - 이 설정을 통해 사용자가 정의한 불용어 목록을 설정해줄 수도 있음
  
- InnoDB에서만 불용어 처리를 무시하는 방법
  - `innodb_ft_enable_stopword` 값을 off로 설정
    - https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ft_enable_stopword
  - `innodb_ft_enable_stopword` 변수는 동적인 시스템 변수이기 때문에 재시작없이 설정 변경 가능

### 전문 검색 인덱스의 가용성
- 전문 검색 인덱스를 사용하려면 아래 두 가지 조건을 갖춰야 함
  - 쿼리 문장이 전문 검색을 위한 문법(`MATCH ... AGAINST ...`)을 사용
  - 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유

```mysql
# 전문 검색 인덱스를 설정해도 이렇게 하면 풀 테이블 스캔 처리
SELECT * FROM tb_test WHERE doc_body LIKE '%애플%';

# 전문 검색을 위한 검색 쿼리를 작성해야 FTS 처리
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('애플', BOOLEAN MODE);
```

### 그 외에 같이 읽어보면 좋은 내용
- [전문검색(Full Text Search) 인덱스를 많이 사용하는가?](https://github.com/gazi-gazi/real-mysql/issues/35)
- [DB만 있으면 되는데, 왜 굳이 검색엔진?](https://velog.io/@jakeseo_me/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-2-DB%EB%A7%8C-%EC%9E%88%EC%9C%BC%EB%A9%B4-%EB%90%98%EB%8A%94%EB%8D%B0-%EC%99%9C-%EA%B5%B3%EC%9D%B4-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84)

## 6. 함수 기반 인덱스
- 일반적인 인덱스는 컬럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 허용
- 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때는 함수 기반 인덱스를 활용
- MySQL 서버에서 함수 기반 인덱스는 가상 컬럼을 이용한 인덱스와 함수를 이용한 인덱스가 존재

### 가상 컬럼을 이용한 인덱스
```mysql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id)
);

ALTER TABLE user
    ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    ADD INDEX ix_fullname(full_name);
```
- 가상 컬럼이 `VIRTUAL`이나 `STORED` 옵션 중 어떤 옵션으로 생성됐든 관계없이 해당 가상 컬럼에 인덱스를 생성할 수 있음
- 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점 존재

> `VIRTUAL` vs `STORED`
> - `VIRTUAL` 또는 `STORED` 키워드는 컬럼 값이 저장되는 방법을 나타내며 컬럼 사용에 영향
> - `VIRTUAL` : 컬럼 값이 저장되지 않지만 행을 읽을 때 BEFORE 트리거 직후에 평가, 가상 컬럼은 스토리지를 차지하지 않음
>   - InnoDB는 가상 컬럼에서 보조 인덱스를 지원, BEFORE 트리거를 수행해야 하는만큼 데이터 볼륨에 따라 CPU성능에 영향 
> - `STORED` : 행이 삽입되거나 업데이트될 때 컬럼 값이 평가되고 저장, 저장된 컬럼에는 저장 공간이 필요하며 인덱싱 가능
> - 키워드가 지정되지 않은 경우 기본값은 `VIRTUAL`
> - 테이블 내에서 VIRTUAL 및 STORED 컬럼을 혼합 할 수 있음

### 함수를 이용한 인덱스
- 가상 컬럼은 5.7 버전에서도 사용할 수 있지만, 함수를 직접 인덱스 생성 구문에 사용할 수 없었음
- 8.0 버전부터 테이블 구조를 변경하지 않고 함수를 직접 사용하는 인덱스를 생성할 수 있게 됨

```mysql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    INDEX ix_fullname((CONCAT(first_name, ' ', last_name)))
);

# 함수 기반 인덱스를 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 함
SELECT * FROM user WHERE CONCAT(first_name, ' ', last_name)='Matt Lee';
```
- 실행계획을 통해 인덱스타는지 확인해보자

## 7. 멀티 밸류 인덱스
- 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- RDBMS들이 JSON 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생
- 멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식이 아닌 아래 함수들을 이용해서 검색해야 함
  - `MEMBER OF()`
  - `JSON_CONTAINS()`
  - `JSON_OVERLAPS()`

```mysql
# credit_scores에 360이 포함된 데이터 조회
SELECT * FROM user WHERE 360 MEMBER OF(credit_info->'$.credit_scores');

# credit_scores에 360과 361이 포함된 데이터 조회
SELECT * FROM user WHERE JSON_CONTAINS(credit_info->'$.credit_scores', CAST('[360, 361]') AS JSON);

# credit_scores에 360 또는 361이 포함된 데이터 조회
SELECT * FROM user WHERE JSON_OVERLAPS(credit_info->'$.credit_scores', CAST('[360, 361]') AS JSON);
```

## 8. 클러스터링 인덱스
- MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(PK를 기준)들 끼리 묶어서 저장하는 형태로 구현
  - 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안
- MySQL에서 클러스터링 인덱스는 InnoDB에서만 지원

### 클러스터링 인덱스
- 테이블의 PK에 대해서만 적용
- PK 값이 비슷한 레코드끼리 묶어서 저장 -> PK 값에 의해 레코드의 저장 위치가 결정
  - PK값이 변경되면 레코드의 물리적인 저장 위치가 바뀜
  - 일종의 테이블 단위의 샤딩이라고 이해함
  - MyISAM, Memory 등의 엔진은 PK가 변경되도 레코드의 위치는 그대로
- 만약 PK가 없으면 InnoDB에서 아래의 우선순위에 따라 PK를 대체할 컬럼을 선택
  - PK가 있으면 PK가 클러스터링 키로 선택
  - `NOT NULL`옵션의 유니크 인덱스 중에 첫 번째 인덱스를 클러스터링 키로  선택
  - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택
- 결과적으로 PK를 선언하지 않으면 내부적으로 컬럼을 추가하게 되고, 이 컬럼은 사용자에게 보이지 않고 접근할 수 없음
- 따라서 중요한 것은 PK를 꼭 선언해서 사용하자

## 9. 유니크 인덱스
- 유니크 옵션은 인덱스라기보다는 제약 조건에 가까움
  - 작업 범위를 제한하는 것이 아니라 필터링하기 위한 요소
- 읽기 성능을 생각해보면 작업 범위가 줄어드는 것이 아니기 때문에 별 차이가 없음
- 오히려 쓰기 시에 고유한 값임을 확인하기 위해 성능 감소
- 유니크 인덱스랑 일반 인덱스를 개별적으로 생성하지 말고 같은 컬럼이라면 유니크 인덱스 하나만 설정하는 것이 좋음

## 10. 외래키
- MySQL에서 외래키는 InnoDB에서만 생성할 수 있고, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스 생성
  - 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음
- InnoDB의 외래키 관리에는 두 가지 중요한 특정이 존재
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음
- 따라서 외래키를 생성하려면 이러한 잠금 경합을 고려해서 모델링을 진행하는 것이 좋음
  - 외래키 설정을 통해 연관 테이블에 잠금이 걸리고, 전체적으로 쿼리의 동시 처리에 영향을 끼침