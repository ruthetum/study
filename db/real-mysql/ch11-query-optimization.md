# 11. 쿼리 최적화 및 최적화
- SQL은 어떠한(what) 데이터를 요청하기 위한 언어이지, 어떻게(how) 데이터를 읽을지를 표현하는 언어는 아님
  - 따라서 쿼리가 빠르게 수행되게 하려면 데이터베이스 서버에서 쿼리가 어떻게 요청을 처리할지 예측할 수 있어야 함
- 일반적으로 애플리케이션 코드를 튜닝해서 성능을 2배 이끌어내는 것은 쉽지 않음
  - 하지만 DBMS에서 몇 십배, 몇 백배 성능 향상이 이뤄지는 것은 흔한 일

## 11.1 쿼리 작성과 연관된 시스템 변수
### 11.1.1 SQL 모드
- `sql_mode`라는 시스템 설정에는 여러 개의 값을 설정할 수 있음
  - 이를 통해 SQL 작성 결과에 영향을 줄 수 있음
- `STRICT_ALL_TABLES` : 일반적인 MySQL에서는 저장하려는 값의 길이가 칼럼 길이를 넘어가더라도 경고만 발생시킨 후 초과한 부분을 자르고 저장한다. 이 옵션을 주면 경고가 아닌 에러를 발생시켜 칼럼 길이를 넘는 데이터를 저장하는 것을 막을 수 있다.
- `STRICT_TRANS_TABLES` : MySQL 서버는 칼럼 타입과 호환되지 않는 값을 저장하려고 할 때 최대한 변환해서 저장하려고 하나, 이 옵션을 주면 강제 변환하지 않고 에러를 발생시킨다.
- `TRADITIONAL` : 위 두 방법보다 조금 더 엄격한 방법으로 ANSI 표준 모드로 동작하도록 한다.
- `ONLY_FULL_GROUP_BY` : MySQL 쿼리에서는 GROUP BY절에 포함되지 않은 칼럼이라도 집합 함수 없이 SELECT나 HAVING절에 이용할 수 있도록 되어 있다. 사실 SQL 표준과는 거리가 있는 방식인데, 이 옵션은 이를 방지하도록 해준다.
- `IGNORE_SPACE` : 프로시저나 함수명과 괄호 사이에 공백이 들어가 있어도 무시해준다.
- `ANSI` : 위의 여러가지 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하도록 한다.

### 11.1.2 영문 대소문자 구분
- MySQL은 설치된 운영체제에 따라 대소문자를 구분함
  - 유닉스 계열 : 대소문자 구분
  - 윈도우 계열 : 대소문작 구분 X
- `lower_case_table_names` 시스템 변수를 통해 설정 가능
  - 0 : 대소문자 구분
  - 1 : 테이블 이름을 모두 소문자로 저장
  - 2 : windows, macOS에서만 가능(저장은 대소문자 구분, 쿼리는 구분 X)

### 11.1.3 MySQL 예약어
- 예약어로 설정된 키워드를 사용하려면 역따옴표(`)나 쌍따옴표(")로 감싸야 함

## 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법
- `[ ]`(대괄호): 해당 키워드 또는 표현식이 선택 사항
- `|`(파이프): 해당 키워드 또는 표현식 중 단 하나만 선택
- `{ }`(중괄호): 해당 키워드 또는 표현식 중 반드시 하나 이상 선택
- `...`: 명시된 키워드 또는 표현식이 반복될 수 있음

## 11.3 MySQL 연산자와 내장 함수
- 다른 DBMS에서 사용되는 기본적인 연산자는 MySQL에서 비슷하게 사용
  - MySQL에서만 사용되는 연산자나 표기법도 존재
- ANSI 표준 형태가 아닌 연산자도 존재하는데 가독성이 좋지 않으므로 되도록이며 ANSI 표준 형태의 연산자 사용을 권장

### 11.3.1 리터럴 표기법 문자열
- 문자열
- 숫자
- 날짜
- 불리언

### 11.3.2 MySQL 연산자
- 동등 비교 (`=`, `<=>`)
  - `<=>`: NULL 값에 대한 비교 수행
- 부정 비교 (`!=`, `<>`)
- NOT 연산자 (`!`)
- AND 연산자 (`&&`)와 OR 연산자 (`||`)
- 나누기 연산자 (`/`, `DIV`)와 나머지 연산자 (`%`, `MOD`)
- REGEXP 연산자
- LIKE 연산자
  - `REGEXP`는 인덱스를 전혀 사용하지 못하지만, `LIKE`는 인덱스를 이용해서 처리할 수 있음
- BETWEEN 연산자
  - `BETWEEN`은 간혹 `IN`연산자와 비슷한 처리를 하는 것 같지만 실제로는 인덱스를 선형적으로 검색(BETWEEN)하냐, 동등 비교(Equal)를 여러 번 수행하느냐의 차이기 때문에 IN 연산자를 통한 처리가 효율적
- IN 연산자

### 11.3.3 MySQL 내장 함수
- NULL 값 비교 및 대체 함수 (`ISNULL`, `IFNULL`)
- 현재 시각 조회 (`NOW`, `SYSDATE`)
  - SYSDATE 함수의 경우 래플리카에서 동일하게 작동하지 않고, 비교 시에 인덱스를 효율적으로 사용하지 못하므로 NOW 함수를 사용하는 것을 권장
- 날짜와 시간의 포맷 (`DATE_FORMAT`, `STR_TO_DATE`)
- 날짜와 시간의 연산 (`DATE_ADD`, `DATE_SUB`)
- 타임스탬프 연산 (`UNIX_TIMESTAMP`, `FROM_UNIXTIME`)
- 문자열 처리 (`RPAD`, `LPAD` / `RTRIM`, `LTRIM`, `TRIM`)
- 문자열 결합 (`CONCAT`)
- GROUP BY 문자열 결합 (`GROUP_CONCAT`)
- 값의 비교와 대체 (`CASE WHEN ...THEN ... END`)
- 타입의 변환 (`CAST`, `CONVERT`)
- 이진값과 16진수 문자열 변환 (`HEX`, `UNHEX`)
- 암호화 및 해시함수 (`MD5`, `SHA`, `SHA2`)
  - MD5, SHA 함수의 결과를 UNHEX 함수를 이용해 이진값으로 변환하여 저장하면 저장공간을 효율적으로 사용
  - 다시 사람이 읽을 수 있는 형태로 되돌릴 때는 HEX 함수를 이용
- 처리 대기 (`SLEEP`)
  - 개발이나 디버깅 용도로 활용 시에 유용
- 벤치마크 (`BENCHMARK`)
  - 쿼리의 성능을 측정할 때 사용
- IP 주소 변환 (`INET_ATON`, `INET_NTOA`)
  - 보통 IP 주소를 VARCHAR(15) 타입에 '.'으로 구분해서 저장, 이 경우 저장공간이 크게 필요
  - INET_ATON은 IPv4 주소(문자열)를 정수형으로 변환, INET_NTOA는 정수형을 IPv4 주소(문자열)로 변환
  - INET6_ATON 함수를 이용하면 IPv6 주소(+IPv4)도 변환 가능
- JSON 포맷 (`JSON_PRETTY`)
- JSON 필드 크기 (`JSON_STORAGE_SIZE`)
- JSON 필드 추출 (`JSON_EXTRACT`)
- JSON 오브젝트 포함 여부 (`JSON_CONTAINS`)
- JSON 오브젝트 생성 (`JSON_OBJECT`)
- JSON 컬럼으로 집계 (`JSON_OBJECTAGG`, `JSON_ARRAYAGG`)
- JSON 데이터를 테이블로 변환(`JSON_TABLE`)

## 11.4 SELECT
### 11.4.1 SELECT 절의 처리 순서
- 일반적으로 아래 순서를 따름
  ```
  (SELECT) -> (FROM) -> (WHERE) -> (GROUP BY) -> (DISTINCT) -> (HAVING) -> (ORDER BY) -> (LIMIT)
  ```

- GROUP BY절이 없이 ORDER BY만 사용된 쿼리에서는 다음 순서를 따르기도 함
  - 드라이빙 테이블 읽어서 ORDER BY 적용
  - 드리븐 테이블 WHERE 적용 및 조인 실행
  - LIMIT 적용

### 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
#### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙

#### 11.4.2.2 WHERE 절의 인덱스 사용

#### 11.4.2.3 GROUP BY 절의 인덱스 사용

#### 11.4.2.4 ORDER BY 절의 인덱스 사용

#### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용

#### 11.4.2.6 GROUP BY 절과 ORDER BY 절의의 인덱스 사용

#### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용

### 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항

### 11.4.4 DISTINCT

### 11.4.5 LIMIT n

### 11.4.6 COUNT()

### 11.4.7 JOIN

### 11.4.8 GROUP BY

### 11.4.9 ORDER BY

### 11.4.10 서브쿼리

### 11.4.11 CTE(Common Table Expression)

### 11.4.12 윈도우 함수(Window Function)

### 11.4.13 잠금을 사용하는 SELECT

## 11.5 INSERT

### 11.5.1 고급 옵션

### 11.5.2 LOAD DATA 명령 주의 사항

### 11.5.3 성능을 위한 테이블 구조

## 11.6 UPDATE와 DELETE

### 11.6.1 UPDATE ... ORDER BY ... LIMIT n

### 11.6.2 JOIN UPDATE

### 11.6.3 여러 레코드 UPDATE

### 11.6.4 JOIN DELETE

## 11.7 스키마 조작(DDL)

### 11.7.1 온라인 DDL

### 11.7.2 데이터베이스 변경

### 11.7.3 테이블 스페이스 변경

### 11.7.4 테이블 변경

### 11.7.5 칼럼 변경

### 11.7.6 인덱스 변경

### 11.7.7 테이블 변경 묶음 실행

### 11.7.8 프로세스 조회 및 강제 종료

### 11.7.9 활성 트랜잭션 조회

## 11.8 쿼리 성능 테스트

### 11.8.1 쿼리의 성능에 영향을 미치는 요소