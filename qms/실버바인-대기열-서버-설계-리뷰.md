# NDC2019 - 실버바인 대기열 서버 설계 리뷰
> 발표: https://www.youtube.com/watch?v=3pO9GJ4zndE
> 자료: http://ndc.vod.nexoncdn.co.kr/NDC2019/slides/NDC2019_0069/index.html

## 목차
- 대기열을 왜 만드나요?
  - 대기열의 등장
  - 대기열의 한계
  
- 대기열을 어떻게 만드나요?
  - 대기열의 목표
  - 상태 관리 전략
  - 서버의 상태 관리 포인트 줄이기
  
- 대기열이 죽으면 어떻게 되나요?
  - 대기열 서버 장애
  - 대기열을 사용하지 않는 경우
  - 대기열에 부하가 심한 경우
  - 서버간 장애가 발생한 경우
  - 클라이언트와 서버간 장애가 발생한 경우
  - 그 외에 게임 서버가 추가적으로 해야할 일
  
- 대기열을 더 잘 만들 수 없을까요?
  - ㅇ

## 대기열을 왜 만드나요?
### 대기열의 등장
- 한 서버에 들어올 수 있는 동접 수의 제한이 있다.
- 서버를 늘리는 것은 시간과 자원이 필요하다.
- 필연적으로 서버에 접속할 수 없는 사용자가 발생한다.

> **넘치는 사용자를 단순히 튕겨내는 것보다는 뭔가 알려주는 게 좋다.**

- 예전에는 서버를 사용자가 선택할 수 있었다.
  - 이 경우에 붐비는 서버를 사용자가 알 수 있었고, 그 상황을 사용자가 알 수 있었다.
- 하지만 요즘 게임들은 사용자가 하나의 서버가 있는 것처럼 보여야 한다.
  - 필요한 경우 알아서 확장도 해야한다.
- 따라서 이런 환경에서 서버별 동접을 보여주기는 어렵다.

> **대기열은 사용자가 접속할 수 있을 때까지 기다리게 해준다.**

<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219017391-d8f58ee1-377c-4c46-99fe-89dd03f8d595.png">

### 대기열의 한계
- 사용자가 대기열에서 천년만년 기다려주지 않는다.
- 대기열은 예측 불가능한 상황에 대한 임시 방편
  - 런칭 또는 주요 이벤트 직후
  - 구조적으로 스케일링이 쉽지 않은 경우
- 사용자의 패턴을 미리 예측 및 사전 대비할 수 있으면 필수는 아님

## 대기열을 어떻게 만드나요?
### 대기열의 목표

1. 게임 서버에 부하를 주지 않고 사용자들을 기다릴 수 있게 해야함
2. 게임 서버보다 안정적이고 빨라야 함
3. 오래 기다린 사람이 가급적이면 먼저 접속해야 함 (선입선출)
4. 기다리는 동안 사용자에게 유용한 정보를 제공해야 함 (대기자 수, 예상 대기 시간)

#### 목표에 따른 실행 사항
> 1. 게임 서버에 부하를 주지 않고 사용자들을 기다릴 수 있게 해야함

→ **대기열을 담당하는 서버를 다른 네트워크에 따로 두자**

> 2. 게임 서버보다 안정적이고 빨라야 함

→ **대기열 서버를 게임 서버와 별도 코드로 독립**

> 3. 오래 기다린 사람이 가급적이면 먼저 접속해야 함 (선입선출)

→ **대기 중인 사용자를 구분할 수 있어야 함**

> 4. 기다리는 동안 사용자에게 유용한 정보를 제공해야 함 (대기자 수, 예상 대기 시간)

→ **대기열 서버 전체가 공유하는 상태 또는 자원이 필요함**

### 상태 관리 전략

<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219019766-0ae85542-f176-407c-bf4c-a90f231ab97f.png">

1. 모든 대기자를 기록한다.
   - 사용자를 모두 기록하기 때문에 사용자를 구분할 수 있는 unique 한 값 필요
   - 대기열에 unique 한 값을 순서대로 쌓음
   
2. 가장 오래된 대기자만 기록한다.
   - 사용자 별로 순차성을 가진 값을 가지고 있기 때문에 대기열에서는 발급, 진입해야되는 두 가지 값만 보관

#### 사용자가 대기열에서 나가는 경우
- 모든 대기자를 기록하는 경우 사용자를 구분하고 있기 때문에 사용자가 대기열에서 나가도 대기열에서 제거 가능
- 그러나 가장 오래된 대기자만 기록하는 경우 해당 정보를 대기열에 알릴 방법이 없음
  - 대기자 수에 허수가 존재

#### 비교
|방법| 장점                     | 단점                         |
|:---:|------------------------|----------------------------|
|**모든 대기자를 기록**| 이론적으로 대기자 수를 정확히 추산 가능 | 상태가 크고 동기화하기 어려움           |
|**가장 오래된 대기자만 기록**| 관리해야되는 상태와 값이 적음       | 대기자 수에 허수가 존재 (대기자 수 과대추산) |


### 동작

> 발표에 활용된 실버라인 대기열 서버의 경우 2번 방안 사용

<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219021563-672f4e85-b3d0-4b33-a5d5-8bf9ab960874.png">

사용자는 대기열 서버 목록 확인

사용자가 대기열 서버에 들어오면 사용자 순번에 따라 **대기표 발권**
- **대기표 발급 순번을 증가**
- 사용자는 **대기표 폴링**
  - 통과 순번과 비교해서 아직 통과 순번이 아니면 튕겨냄
  - 통과 순번과 비교해서 통과 순번이 되었다면 **입장권 발권**
  - 입장권을 통해 게임 서버에 접속

게임 서버는 아래 1~2 과정 속에서 아래 일들을 수행
- 대기열 서버가 발급한 **입장권 검증**
- 가능하면 순번이 이미 사용되었는지 확인
  - 재사용 공격(reply attack) 방지
  - 입장권의 만료 기한을 참고해서 캐싱
- 대기열 서버에 **동접 수에 맞춰 적절한 피드백 전송** 

<br/>

#### 게임 서버와 대기열 서버의 피드백
게임 서버가 대기열 서버에 통과 순번을 증가시킬 것을 요청
- 일반적으로 대기열 압력과 실제 진입 사용자 수는 다를 수 있음
  - 대기열 압력: 서버에서 증가시키고자 했던 사용자의 수
  - 피드백이 느렸거나 허수가 존재하는 경우

대기열 압력을 너무 높이면 서버가 터질 수 있음
- 한계 동접에 근접하면서 증가 폭을 줄여야 함
- 여유가 있어도 보통 로그인은 코스트가 큰 작업이기 때문에 무작정 사용자를 들일 수 없음

너무 적게 올려도 사용자의 불평이 증가함

따라서 적절한 대기열 압력 설정이 필요
- 피드백으로 제공하는 대기열 압력 = min(남은 동접 x 피드백 비율, 시간당 허용 진입)
- 상수 값은 실험적으로 결정 by 부하테스트
  - 실시간으로 변경 가능하게 설정

### 서버의 상태 관리 포인트 줄이기
HTTP는 상태가 없는 프로토콜
- 이를 이용하면 자연스럽게 상태가 없는 프로토콜 제공

대기표를 매번 보냄 (= HTTP 쿠키)
- 그리고 이를 암호학적 방법으로 인증(authentication)

상태 관리에 대한 책임을 클라이언트에게 전달
- 클라이언트가 대기표를 관리

<img width="600" alt="스크린샷 2023-02-15 오후 9 20 42" src="https://user-images.githubusercontent.com/59307414/219025952-c1dcd930-3f6f-4120-ba26-c26b625140a4.png">

`cutoff`, `serial` 두 가지 키로 대기열 관리 가능 

## 대기열이 죽으면 어떻게 되나요?
### 대기열 서버 장애
당연히 정상적인 서비스를 제공하는데 어려움

**저장소(ex. redis)가 죽으면 대기열 전체가 멎음**
- AWS도 만능이 아님
- 횡분할(샤딩)을 적용하는 경우 대기 순서와 진입 순서가 달라짐
  - 대기열 서버를 여러 개 두는 방법의 경우 각 대기열 간의 동기화가 필요하기 때문에 어려움 발생
- 따라서 부하를 덜 주는 방법을 찾아야 함

**대기열이 죽었을 때는 게임 서버가 다르게 행동할 수 있게 해야 함** (Graceful Failback)

### 대기열을 사용하지 않는 경우
<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219027684-2a82d41e-b3be-4cb5-bc6e-40add8d3754b.png">

- 서버 목록 조회 시 클라이언트는 대기열을 사용하지 않음을 알고 있음
- 게임 서버에서는 입장권 검증없이 로그인 허용 (게임 서버도 대기열 서버가 없음을 인지)

### 대기열에 부하가 심한 경우
<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219027734-439be19b-d0f0-4f25-9044-c838c45adb8d.png">

- 클라이언트는 대기표 발권을 반복한 후 실패 시 게임 서버로 입장권없이 로그인 시도
- 게임 서버도 피드백 과정에서 장애가 발생했음을 인지하고 입장권 검증 없이 로그인 허용

### 게임 서버와 대기열 서버 간 장애가 발생한 경우
<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219028007-d11120d0-567c-44b5-94d3-caa0ff18789e.png">

- 클라이언트는 정상적으로 입장권을 발급받음
- 게임 서버는 피드백 과정에서 대기열 서버에 장애가 난 것으로 판단하고 입장권 검증없이 로그인 허용

### 클라이언트와 대기열 서버간 장애가 발생한 경우
<img width="600" alt="스크린샷" src="https://user-images.githubusercontent.com/59307414/219028570-10b81031-986a-4aa0-94e4-b748f44055e9.png">

- 클라이언트는 대기표 발권을 반복 실패 후 게임 서버로 입장권없이 로그인 시도
- 게임 서버는 대기열 서버가 정상임을 알고 있기 때문에 입장권이 없는 경우 반복해서 로그인 거부
- 이 경우 클라이언트는 왜 로그인이 안 되는 것인지 모르기 때문에 게임 서버에서 반복해서 로그인 거부를 한 경우 네트워크 이슈임을 인지할 수 있게 해야 함
  - 입장권이 없는 이유가 클라이언트와 대기열 서버간의 네트워크 이슈이기 때문에 네트워크 이슈를 alert 해야 함

<br/>

### 그 외에 게임 서버가 추가적으로 해야할 일
대기열 서버가 발급한 입장권을 잘 검증한다.
- 대기열 서버가 죽은 것 같으면 로그인 허용

가능하면 이미 순번이 사용되었는지 확인한다.
- 재사용 공격 방지

대기열 서버에게 동접에 맞춰 적절한 피드백을 보낸다.
- 피드백이 계속 실패하면 대기열 서버가 죽은 것으로 판단
- 단, 한 번이라도 성공하면 대기열 서버가 살아난 것으로 간주

## 대기열을 더 잘 만들 수 없을까요?
### 성능 최적화
Redis cluster 활용

약간의 지연을 통해 대역폭을 증가

### 대기 시간 추정