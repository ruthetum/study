# 비동기 통신 + SAGA 패턴 적용해보기

## 도입
> MSA에서 모든 비즈니스 규칙들을 실시간으로 일관성을 맞춰줘야 할까?

## 상황

- 예를 들어 쇼핑몰에서 물건을 `주문`하고, `결제` 처리가 되고, 결제가 완료됐을 때 주문자에게 `이메일`을 전송해야 하는 상황

- 보통은 주문된 다음에 결제가 되고 , 결제 내용이 이메일로 통보되는 것이 순차적인 일 처리 순서이다. (아래 `case 1`의 구조)

- 그런데 주문이 몰리면 결제가 지연되거나 처리되지 않는 경우가 발생하는 등의 상황이 발생할 수 있고, 결제 서비스에서 발생한 장애가 주문 서비스로 전파돼서 주문 서비스가 지연될 수 있다.

- 이런 상황에서는 일단 주문을 많이 받고 보는 게 효율적이다.

- 구조 별 case를 나눠서 실험을 진행하고 비교하자.

## 구조

- 처음에는 비동기 통신 + 로컬 트랜잭션 처리를 목적으로 case 2개를 만들어서 공부할 예정이었다.
    - 근데 이 외에 조금 더 효율적으로 보이는 case 1개와 결과가 궁금한 case 1개가 있어서 더 추가해서 4개의 case를 실험할 예정이다.

- 공통적으로 세 개의 마이크로 서비스가 존재하고, `주문`, `결제`, `메일`로 이루어진다.

- 주문이 요청되면 **주문 서비스**에서는 주문을 저장하고 결제 서비스에 결제를 요청한다.

- **결제 서비스**에서는 결제를 진행하고 결제 내역을 저장한다.
    - 결제는 임시로 카카오 페이 테스트 API를 활용

- 이후 결제가 완료된 경우 결제 완료 및 최종 주문 완료에 대해 **메일 서비스** 메일을 발송한다.

> MSA에서 서비스 간 일관성 보장 공부하기
> - `case 1`, `case 2`에서는 **SAGA 패턴**을 적용하여 서비스가 작업 실패했을 때를 대비하여 분산 환경에서 원자성을 보장하고자 한다.
>    - cf. SAGA 패턴 : https://azderica.github.io/01-architecture-msa/


### case 1. MVC + 단일 트랜잭션 
![image](https://user-images.githubusercontent.com/59307414/163173992-8e9ec43c-42d2-4159-a0f4-77d182cd7716.png)

- 모든 서비스를 MVC 기반, RDBMS에 내역을 저장하고, 위 과정을 순차적으로 진행한다.

### case 2. MVC + 비동기 통신
![case2](https://user-images.githubusercontent.com/59307414/163399043-78ca2437-8fd5-4972-9a3a-1783dde28eea.png)

- 모든 서비스를 MVC 기반, RDBMS에 내역을 저정하지만 서비스 사이에 메시지 브로커(Kafka)를 두어 동기 통신이 아닌 **서비스간 비동기 통신**을 진행한다.

### case 3. MVC + WebFlux(알림) + 비동기 통신
![case3](https://user-images.githubusercontent.com/59307414/163398911-8bea047a-abe1-470f-a826-7b08a489dc20.png)

- `case 2`와 기본적인 구조는 비슷하다.

- 하지만 메일 서비스를 실제 상황에서 고려해봤을 때 결제 서비스 외에도 다른 서비스에서 많은 요청을 받을 수 있다.

- 순간적인 요청이 많이 들어왔을 때 지연이 적어야 하기 때문에 MVC보다는 적은 리소스에서 효율적으로 운영할 수 있는 non blocking 방식의 **WebFlux**가 효율적일 것 같다고 생각했다.

- 추가로 메일 전송 내역은 데이터의 사용을 고려해봤을 전송 이력은 조회할 뿐 수정 기능이나 트랜잭션 처리에 대해 크게 깊이를 두지 않기 때문에 Mongo DB를 활용하면 보다 효율적일 것이라고 생각했기 때문에 데이터베이스 수정을 계획했고,

- 단순히 `Spring Data MongoDB`를 활용하는 것이 아니라 WebFlux의 비동기성을 좀 더 효율적으로 활용하기 위해 `Spring Data MongoDB Reactive`을 활용하고자 했다.

### case 4. WebFlux + R2DBC + 비동기 통신

![case4](https://user-images.githubusercontent.com/59307414/163398652-c5e9b52a-c3fc-4163-bf51-9bf8c148a563.png)

- 모든 서비스를 WebFlux 기반으로 만들고, RDBMS에 기존 드라이버를 활용하는 경우 Blocking 이슈때문에 효율이 떨어질 수 있기 때문에 **Spring Data R2DBC**와 같은 리액티브 API를 활용해서 데이터를 저장할 예정이다.


### Appendix
#### Fallback vs Fallback Factory
- 단순히 Fallback을 쓸 경우 오류는 핸들링할 수 있지만 정확히 어떤 오류에 의해 예외 처리되었는지 설정할 수 없다.
- Fallback Factoty를 활용하는 경우 발생한 오류에 따라 알맞는 예외 처리를 제공할 수 있다.