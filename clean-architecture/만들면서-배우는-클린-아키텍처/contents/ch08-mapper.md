# ch 08. 경계 간 매핑하기

## '매핑하지 않기(No mapping)' 전략

<img width="636" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/922bb64f-d728-475d-a090-74f729bc54d3">


> 포트 인터페이스가 도메인 모델을 입출력 모델로 사용하면 두 계층 간의 매핑을모할 필요가 없다.

웹 계층과 영속성 계층은 모델에 대해 특별한 요구사항이 있을 수 있다. 예를 들어, 웹 계층에서 REST로 모델을 노출시켰다면 모델을 JSON으로 직렬화하기 위한 애너테이션을 모델 클래스의 특정 필드에 붙여야 할 수도 있다.

도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 Account 도메인 모델 클래스는 이런 모든 요구사항을 다뤄야 한다.

Account 클래스는 웹, 애플리케이션, 영속성 계층과 관련된 이유로 인해 변경돼야 하기 때문에 단일 책임 원칙을 위반한다.

> 그럼 ‘매핑하지 않기’ 전략을 절대로 쓰면 안 된다는 뜻일까? 그렇지는 않다.

간단한 CRUD 유스케이스를 생각해보자. 같은 필드를 가진 웹 모델을 도메인 모델로, 혹은 도메인 모델을 영속성 모델로 매핑할 필요가 있을까? 그럴 필요는 없다.

모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 ‘매핑하지 않기’ 전략은 완벽한 선택지다.

그러나 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제를 다루게 되면 곧바로 다른 전략을 취해야 한다.
- 물론 어떤 매핑 전략을 선택했더라도 나중에 언제든 바꿀 수 있다.

## '양방향(Two-Way)' 매핑 전략
<img width="635" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/a479c854-6856-4150-93fc-97839597ae2b">

> 각 어뎁터가 전용 모델을 가지고 있어서 해당 모델을 도메인 모델로, 도메인 모델을 해당 모델로 매핑할 책임을 가진다.

각 계층이 전용 모델을 가지고 있는 덕분에 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없다.
- 이는 단일 책임 원칙을 만족한다.

물론 다른 매핑 전략과 마찬가지로 양방향 매핑도 단점이 있다.

먼저, 너무 많은 보일러플레이트 코드가 생긴다. 코드의 양을 줄이기 위해 매핑 프레임워크를 사용하더라도 두 모델 간 매핑을 구현하는 데는 꽤 시간이 든다.

또 다른 단점은 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용되고 있다는 것이다. 인커밍 포트와 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용한다. 도메인 모델은 도메인 모델의 필요에 의해서만 변경되는 것이 이상적이지만 바깥쪽 계층의 요구에 따른 변경에 취약해지는 것이다.

'매핑하지 않기' 전략과 마찬가지로 '양방향 매핑' 전략도 은총알(silver bullet)이 아니다. 어떤 매핑 전략도 철칙처럼 여겨져서는 안 된다. 그 대신 각 유스케이스마다 적절한 전략을 택할수 있어야한다.

## '완전(Full)' 매핑 전략
<img width="635" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/c5e04fa6-c86f-4865-bd56-0778e8eb3997">

> 각 연산이 전용 모델을 필요로 하기 때문에 웹 어뎁터와 애플리케이션 계층 각각이 자신의 전용 모델을 각 연산을 실행하는데 필요한 모델로 매핑한다.

이 매핑 전략에서는 각 연산마다 별도의 입출력 모델을 사용한다.

계층 경계를 넘어 통신할 때 도메인 모델을 사용하는 대신 각 작업에 특화된 모델을 사용한다.
- e.g. SendMoneyUseCase 포트의 입력 모델인 SendMoneyCommand
- 이런 모델을 가리켜 '커맨드(command)', '요청(request)'와 같은 단어로 표현한다.

당연하겠지만 한 계층을 다른 여러 개의 커맨드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요하다. 하지만 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.

## '단방향(One-Way)' 매핑 전략
<img width="634" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/50806520-c006-46c9-914c-537325e6b8dd">

> 동일한 '상태' 인터페이스를 구현하는 도메인 모델과 어뎁터 모델을 이용하면 각 계층은 다른 계층으로부터 온 객체를 단방향으로 매핑하기만 하면 된다.

이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 구현한다. 이 인터페이스는 관련 있는 특성(attribute)에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화 한다.

이 전략에서 매핑 책임은 명확하다. 만약 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것이다. 그러므로 각 계층은 한 방향으로만 매핑한다. 그래서 이 전략의 이름이 ‘단방향’ 매핑 전략인 것이다.
- 하지만 매핑이 계층을 넘나들며 퍼져 있기 때문에 이 전략은 다른 전략에 비해 개념적으로 어렵다.

이 전략은 계층 간의 모델이 비슷할 때 가장 효과적이다. 예를 들어, 읽기 전용 연산의 경우 상태 인터페이스가 필요한 모든 정보를 제공하기 때문에 웹 계층에서 전용 모델로 매핑 할 필요가 전혀 없다.

## 언제 어떤 매핑 전략을 사용할 것인가?

> 그때 그때 다르다

각 매핑 전략이 저마다 장단점을 갖고 있기 때문에 한 전략을 전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 한다.

같은 코드에 여러 패턴을 섞으면 어수선하게 느껴져서 우리의 본능을 거스르는 일이기는 하지만 특정 작업에 최선의 패턴이 아님에도 그저 깔끔하게 느껴진다는 이유로 선택해버리는 것은 참으로 무책임한 처사다.

언제 어떤 전략을 사용할지 결정하려면 팀 내에서 합의할 수 있는 가이드라인을 정해둬야 한다.

이 가이드라인은 어떤 상황에서 어떤 매핑 전략을 가장 먼저 택해야 하는가에 답할 수 있어야 한다. 또한 왜 해당 전략을 최우선으로 택해야 하는지도 설명할 수 있어야 한다. 그래야 그러한 근거들이 시간이 흐른 후에도 여전히 유효한지 평가할 수 있기 때문이다.

### 예시

> 변경 유스케이스와 쿼리 유스케이스에 서로 다른 매핑 가이드라인을 정해뒀다고 해보자. 또, 웹 계층과 애플리케이션 계층 사이에서 사용할 매핑 전략과 애플리케이션 계층과 영속성 계층 사이에서 사용할 매핑 전략을 다르게 세웠다고 가정해보자.

변경 유스케이스를 작업하고 있다면 웹 계층과 애플리케이션 계층 사이에서는 유스케이스 간의 결합을 제거하기 위해 ‘완전 매핑’ 전략을 첫 번째 선택지로 택해야 한다. 이렇게 하면 유스케이스별 유효성 검증 규칙이 명확해지고 특정 유스케이스에서 필요하지 않은 필드를 다루지 않아도 된다.

변경 유스케이스를 작업하고 있다면 애플리케이션과 영속성 계층 사이에서는 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해서 ‘매핑하지 않기’ 전략을 첫 번째 선택지로 둔다. 하지만 애플리케이션 계층에서 영속성 문제를 다뤄야 하게 되면 ‘양방향 매핑’ 전략으로 바 꿔서 영속성 문제를 영속성 계층에 가둘 수 있게 한다.

쿼리 작업을 한다면 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 ‘매핑하지 않기’ 전략이 웹 계층과 애플리케이션 계층 사이, 애플리케이션 계층과 영속성 계층 사이에서 첫 번째 선택지가 돼야 한다. 하지만 애플리케이션 계층에서 영속성 문제나 웹 문제를 다뤄야 하게 되면 웹 계층과 애플리케이션 계층, 애플리케이션 계층과 영속성 계층 사이에서 각각 ‘양방향 매핑‘ 전략으로 바꿔야 한다.
