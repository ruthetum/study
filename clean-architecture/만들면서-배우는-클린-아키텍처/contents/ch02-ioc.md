# ch 02. 의존성 역전하기

## 단일 책임 원칙 (Single Responsibility Principle, SRP)

일반적인 해석

> 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

실제 정의

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

컴포넌트를 변경할 이유가 한 가지라면 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 기대한 대로 동작하기 때문이다.

A 컴포넌트가 B 컴포넌트에 의존하고 있다면, B 컴포넌트를 수정하는 경우 A 컴포넌트도 수정이 필요하다.

실제로 많은 코드는 단일 책임 원칙을 위반하기 때문에 시간이 지날수록 변경하기 어려워지고 변경을 위한 비용도 증가한다.

## 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

> 코드 상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다. 민약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러를 제어할 수 없기 때문에 이 의존성을 역전시킬 수 없다.

> 의존성 역전은 어떻게 동작할까?

도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 '변경할 이유'의 개수를 줄여야 한다.

<img width="534" alt="" src="https://github.com/ruthetum/study/assets/59307414/8f5132fd-eb97-4d6b-a088-7dc622b24c3a">

위 구조에서 도메인 계층에는 서비스, 영속성 계층에는 엔티티와 래퍼지토리가 존재한다.

엔티티는 도메인 객체를 표현하고, 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 엔티티를 도메인 계층으로 올린다.

이 경우 영속성 계층의 래퍼지토리가 도메인 계층에 있는 엔티티를 의존하기 때문에 두 계층 사이에 순환 의존성(circular dependency)이 생긴다. (이 부분이 DIP를 적용하는 부분이다.)

<img width="519" alt="" src="https://github.com/ruthetum/study/assets/59307414/5b37da5f-d03c-49c4-936e-2685e6e6d2c3">

도메인 계층에 래퍼지토리에 대한 인터페이스를 만들고, 실제 래퍼지토리는 영속성 계층에서 구현한다.

도메인 계층에 인터페이스를 도입함으로써 의존성을 역전시킬 수 있고, 그 덕분에 영속성 계층이 도메인 계층에 의존하게 된다.

## 클린 아키텍처

클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다.\

이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의조성이 도메인 코드를 향하고 있다.

<img width="557" alt="" src="https://github.com/ruthetum/study/assets/59307414/e31663e2-2804-4797-b191-5fa322973e64">

아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 존재한다.

유스케이스 앞에서 서비스로 불렸던 것으로, 단일 책임을 갖기 위해 조금 더 세분화한다. (이전에 이야기했던 넓은 서비스 문제를 피하기 위함)

코어의 주변으로 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 컴포넌트들이 존재한다.

> 물론 클린 클린 아키텍처에도 대가가 따른다.

도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

영속성 계층에서 ORM(object-relational mapping, 객체-관계 매핑) 프레임워크를 사용하는 경우, 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클 래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다.

즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다. 이는 도메인 계층과 다른 계층들 사이에서도 마찬가지다.

## 육각형 아키텍처 (헥사고날 아키텍처)

> 육각형 모양은 사실 아무 의미도 없다.
> 
> 육각형 아키텍처는 애플리케이션 코어가 각 어댑터와 상호작용하기 위해 특정 포트를 제공하기 때문에
> 
> ‘포트와 어댑터’(ports-and-adapters) 아키텍처라고도 불린다.

<img width="640" alt="스크린샷 2023-07-25 오후 7 08 02" src="https://github.com/ruthetum/study/assets/59307414/f027ba43-2133-404b-b3b2-0d9e1b2c431e">

육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부 로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다. 대신 모든 의조성은 코어를 향한다.

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.

주도하는 어댑터(driving adapter)에게는 그러한 포트가 코어에 있는 유스케이스 클래스들에 의해 구현되고 호출되는 인터페이스가 될 것이고,

주도되는 어댑터(driven adapter)에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.
