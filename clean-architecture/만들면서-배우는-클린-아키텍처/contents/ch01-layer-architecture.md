# ch 01. 계층형 아키턱처의 문제는 무엇일까?

## 계층형 아키텍처
<img width="301" alt="스크린샷 2023-07-22 오후 3 02 16" src="https://github.com/ruthetum/study/assets/59307414/97dea93a-4db0-4127-9dc6-3e5d6b024eff">

웹 계층에서는 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청한다.

서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출한다.

## 계층형 아키텍처의 문제점
사실 계층형 아키텍처는 견고한 아키텍처 패턴이다.

계층을 잘 이해하고 구성한다면 계층 별로 독립적으로 도메인 로직을 작성할 수 있음. 또한 도메인 로직에 영향을 주지 않고, 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다.

### 문제점 1. 데이터베이스 주도 설계를 유도한다.

전통적인 계층형 아키텍처의 토대는 데이터베이스이다.

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 데이터베이스에 의존하고, 결과적으로 영속성 계층을 토대로 만들어진다.

하지만 우리가 만드는 대부분의 애플리케이션은 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙과 정책을 편리하게 활용하는 것이다.

이 때는 상태(state)가 아니라 행동(behavior)을 중심으로 모델링하고, 상태도 중요하지만 실제로 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다.

> 그러면 우리는 왜 '도메인 로직'이 아닌 '데이터베이스'를 토대로 아키텍처를 만들게 되었을까?

그동안 만들어 본 애플리케이션의 유스케이스를 한번 떠올려보면 대부분 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현한다.

전통적인 계층형 아키텍처에서는 합리적(의존성의 방향에 따라 구현)인 방법이지만, 비즈니스 관점에서는 적합하지 않은 방법이다.

다른 무엇보다도 도메인 로직을 먼저 만들어야 우리 로직을 제대로 이해했는지 확인할 수 있다. 그리고 이 도메인 로직이 맞다는 것을 확인한 후 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.

- 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM(object-relational mapping, 객체 관계 매핑) 프레임워크를 사용하기 때문 (e.g. JPA, Hibernate)
- ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받음

<img width="534" alt="스크린샷 2023-07-22 오후 3 17 44" src="https://github.com/ruthetum/study/assets/59307414/8f5132fd-eb97-4d6b-a088-7dc622b24c3a">

ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.

계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 엔티티에 접근할 수 있다.

하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.

서비스는 영속성 모델을 비즈니스 모델처럼 사용하고, 이로 인해 서비스는 도메인 로직뿐만 아니라 영속성 계층과 관련 작업을 수행해야 한다.

- 트랜잭션
- 즉시로딩/지연로딩
- 캐시 플러시

영속성 코드가 사실상 도메인 코드에 포함되어 둘 중 하나만 바꾸는 것이 매우 어려워진다.

이는 유연하고 확장 가능한 아키텍처를 만들기 위한 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.

### 문제점 2. 지름길을 택하기 쉬워진다.
전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은 특정한 계층에서는
같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.

> 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 된다. 
> 
> 딱 한번 이렇게 하는 것은 괜찮을 수 있다. 하지만 처음이 힘들지 그다음부터는 죄책감이 훨씬 덜하다. 또 동료가 그렇게 한다면, 나 역시 그렇게 해도 된다는 마음이 들지 않을까?
> 
> ref. 깨진 창문 이론

<img width="568" alt="스크린샷 2023-07-22 오후 3 24 19" src="https://github.com/ruthetum/study/assets/59307414/fe81770a-67cc-4138-8073-f8c782a9b0e1">

결국 이러한 형태로 개발이 진행되다보면 영속성 계층 혹은 최하단 계층이 매우 비대해진다.

어떤 계층에도 속하지 않는 것처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들도 이처럼 아래 계층으로 내릴 가능성이 높아진다.

### 문제점 3. 테스트하기 어려워진다.
<img width="516" alt="스크린샷 2023-07-22 오후 3 28 19" src="https://github.com/ruthetum/study/assets/59307414/f50a7fb3-e1b6-426d-ad3e-7c861088d2ed">

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다.

이러한 형태가 지속된다면 두 가지 문제점이 발생한다.

1. 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 됨
2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(mocking)해야함

### 문제점 4. 유스케이스를 숨긴다.

개발자들은 새로운 유스케이스를 구현하는 새로운 코드를 짜는 것을 선호한다. 그러나 실제로는 새로운 코드를 짜는 데 시간을 쓰기보다는 기존 코드를 바꾸는 데 더 많은 시간을 쓴다.

<img width="568" alt="스크린샷 2023-07-22 오후 3 31 02" src="https://github.com/ruthetum/study/assets/59307414/5e6e8a86-4e46-48bc-99a2-825b567ef3db">

계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다. 또한 계층형 아키텍처는 도메인 서비스의 '너비'에 관한 규칙을 강제하지 않는다. 따라서 여러 개의 유스케이스를 담당하는 매우 넓는 서비스가 만들어질 수 있다.

넓은 서비스는 영속성 계층에 많은 의존성을 갖고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 그렇게 되면 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

### 문제점 5. 동시 작업이 어려워진다.
코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고, 이는 병합 충돌(merge conflict)과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하기 때문이다.