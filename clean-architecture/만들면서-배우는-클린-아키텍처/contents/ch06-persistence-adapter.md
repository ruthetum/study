# ch 06. 영속성 어뎁터 구현하기

계층역 아키텍처에서는 결과적으로 모든 것이 영속성 계층에 의전하게 '데이터베이스 주도 설계'가 된다.

이러한 의존성을 역전시키기 위해서는 영속성 계층을 애플리케이션 계층의 플러그인으로 만들어서 사용해야 한다.

## 의존성 역전
<img width="639" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/fbc7609e-e5b1-4a1d-b856-bd603fc7156b">

> 코어의 서비스가 영속성 어뎁터에 접근하기 위해 포트를 사용한다.

애플리케이션 서비스에서는 영속성 기능을 사용하기 위해 포트 인터페이스를 호출한다.
- 이 포트는 영속성 작업을 수행하고, 데이터베이스와 통신할 책임을 가진 영속성 어뎁터 클래스에 의해 구현된다.

육각형 아키텍처에서 영속성 어뎁터는 '주도되는' 혹은 '아웃고잉' 어뎁터다. 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않기 때문이다.

포트는 사실상 애플리케이션 서비스와 영속성 코드 사이의 간접적인 계층이다.
- 영속성 문제에 신경 쓰지 않고 도메인 코드를 개발한다.
- 영속성 코드를 리팩토링하더라도 코어 코드를 변경하지 않아도 된다.
- 영속성 코드가 포트에 명세된 계약을 만족하는 한, 코어에 영향을 미치지 않으면서 영속성 코드를 마음껏 수정할 수 있다.

## 영속성 어뎁터의 책임
1. 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 입력을 데이터베이스로 보낸다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

## 포트 인터페이스 나누기
서비스를 구현하면서 생기는 의문은 데이터베이스 연산을 정의하고 있는 포트 인터페이스를 어떻게 나눌 것인가다.

<img width="634" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/7265df13-5d75-4af3-b473-32802e284f74">

보통은 위와 같이 특정 엔티티가 필요로 하는 모든 데이터베이스 연산을 하나의 레포지터리 인터페이스에 넣어둔다.
- 하나의 아웃고잉 포트(AccountRepository)에 모든 데이터베이스 연산을 모아두면 모든 서비스가 실제로는 필요하지 않는 메서드에 의존하게 된다.

인터페이스 분리 원칙(interface Segregation Principle, ISP)은 이 문제의 답을 제시한다.
- 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 작은 인터페이스로 분리해야 한다

<img width="634" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/2f00089a-2a0e-46be-a1e4-e30f1cb22263">

위와 같이 인터페이스를 분리하면 각 서비스는 실제로 필요한 메서드에만 의존하게 된다.

테스트 시 어떤 메서드를 모킹할지 고민할 필요가 없어진다. 대부분의 경우 포트당 하나의 메서드만 존재하게 된다.
- 물론 모든 상황에 '포트 하나당 하나의 메서드'를 적용하지 못할 수도 있다. 응집성이 높고 함께 사용될 때는 하나의 인터페이스에 데이터베이스 연산들을 묶어야 할 수도 있다.

## 영속성 어뎁터 나누기
<img width="635" alt="스크린샷" src="https://github.com/ruthetum/study/assets/59307414/6946f124-5dee-482b-9eff-f4eecb335f60">

하나의 애그리거트당 하나의 영속성 어뎁터를 만들어서 여러 개의 영속성 어뎁터를 만들 수 있다.
- 애그리거트: 불변식을 만족해서 하나의 단위로 취급될 수 있는 연관 객체의 모음

## 데이터베이스 트랜잭션은 어떻게 해야 할까?
자바와 스프링에서 가장 쉬운 방법은 @Transactional 애너테이션을 애플리케이션 서비스 클래스에 붙여서 스프링이 모든 public 메서드를 트랜잭션으로 감싸게 하는 것이다.

만약 서비스가 @Transactional 애너테이션으로 오염되지 않고 깔끔하게 유지되길 원한다면 AspectJ 같은 도구를 이용해 관점 지향 프로그래밍(aspect-oriented programming)으로 트랜잭션 경계를 코드에 위빙(weaving)할 수 있다.